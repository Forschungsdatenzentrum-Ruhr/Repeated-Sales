#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA),
##gen price difference to parent
#this needs to be variable depending on object type
kp_pd_to_parent = kaufpreis - baseline$kaufpreis,
rent_pd_to_parent = mietekalt - baseline$mietekalt,
##gen time difference to parent
td_to_parent =  (as.numeric(ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,kaufpreis,kp_pd_to_parent,mietekalt,rent_pd_to_parent,ajahrmonat,ejahrmonat,td_to_parent,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_outer = rbind(final_outer, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
######################
#Classifcations
######################
#length(unique_latlon)
for(i in 1:100){
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = as.numeric(unique_wohnflaeche[!unique_wohnflaeche %in% missings])
printer(i,by = 10)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ajahrmonat)) - as.numeric(inner_dummy$ejahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA),
##gen price difference to parent
#this needs to be variable depending on object type
kp_pd_to_parent = kaufpreis - baseline$kaufpreis,
rent_pd_to_parent = mietekalt - baseline$mietekalt,
##gen time difference to parent
td_to_parent =  (as.numeric(ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,kaufpreis,kp_pd_to_parent,mietekalt,rent_pd_to_parent,ajahrmonat,ejahrmonat,td_to_parent,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_outer = rbind(final_outer, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
final_outer = c()
######################
#Classifcations
######################
#length(unique_latlon)
for(i in 1:100){
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = as.numeric(unique_wohnflaeche[!unique_wohnflaeche %in% missings])
printer(i,by = 10)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ajahrmonat)) - as.numeric(inner_dummy$ejahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA),
##gen price difference to parent
#this needs to be variable depending on object type
kp_pd_to_parent = kaufpreis - baseline$kaufpreis,
rent_pd_to_parent = mietekalt - baseline$mietekalt,
##gen time difference to parent
td_to_parent =  (as.numeric(ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,kaufpreis,kp_pd_to_parent,mietekalt,rent_pd_to_parent,ajahrmonat,ejahrmonat,td_to_parent,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_outer = rbind(final_outer, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
#count occurences of parent objects
count_parents = count(final_outer,obj_parent)
keep_parents = count_parents[1][count_parents[2] > 1]
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
View(final_list)
final_outer = c()
final_inner = c()
final_list = c()
######################
#Classifcations
######################
#length(unique_latlon)
for(i in 1:100){
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = as.numeric(unique_wohnflaeche[!unique_wohnflaeche %in% missings])
printer(i,by = 10)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ajahrmonat)) - as.numeric(inner_dummy$ejahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA),
##gen price difference to parent
#this needs to be variable depending on object type
kp_pd_to_parent = kaufpreis - baseline$kaufpreis,
rent_pd_to_parent = mietekalt - baseline$mietekalt,
##gen time difference to parent
td_to_parent =  (as.numeric(ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,kaufpreis,kp_pd_to_parent,mietekalt,rent_pd_to_parent,ajahrmonat,ejahrmonat,td_to_parent,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_outer = rbind(final_outer, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
#count occurences of parent objects
count_parents = count(final_outer,obj_parent)
keep_parents = count_parents[1][count_parents[2] > 1]
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
View(final_list)
match("5828748.98989879802108.078689508",berlin_only$latlon_utm)
######################
#Classifcations
######################
#length(unique_latlon)
i=47
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = as.numeric(unique_wohnflaeche[!unique_wohnflaeche %in% missings])
View(outer_dummy)
######################
#Classifcations
######################
#length(unique_latlon)
i=match("5828748.98989879802108.078689508",berlin_only$latlon_utm)
test = filter(berlin_only,latlon_utm == "5828748.98989879802108.078689508")
View(test)
######################
#Classifcations
######################
#length(unique_latlon)
i=match("5828748.98989879802108.078689508",unique_latlon)
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = as.numeric(unique_wohnflaeche[!unique_wohnflaeche %in% missings])
View(outer_dummy)
unique_wohnflaeche = unique_wohnflaeche[!unique_wohnflaeche %in% missings]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = unique_wohnflaeche[!unique_wohnflaeche %in% missings]
final_outer = c()
final_inner = c()
final_list = c()
######################
#Classifcations
######################
#length(unique_latlon)
#i=match("5828748.98989879802108.078689508",unique_latlon)
for(i in 1:100){
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
#get unique values for living space and drop missings
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
unique_wohnflaeche = unique_wohnflaeche[!unique_wohnflaeche %in% missings]
printer(i,by = 10)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ajahrmonat)) - as.numeric(inner_dummy$ejahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA),
##gen price difference to parent
#this needs to be variable depending on object type
kp_pd_to_parent = kaufpreis - baseline$kaufpreis,
rent_pd_to_parent = mietekalt - baseline$mietekalt,
##gen time difference to parent
td_to_parent =  (as.numeric(ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,kaufpreis,kp_pd_to_parent,mietekalt,rent_pd_to_parent,ajahrmonat,ejahrmonat,td_to_parent,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_outer = rbind(final_outer, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
#count occurences of parent objects
count_parents = count(final_outer,obj_parent)
keep_parents = count_parents[1][count_parents[2] > 1]
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
View(final_list)
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% distinct() %>% arrange(obj_parent,counting_id)
View(final_list)
#count occurences of parent objects
count_parents =  final_outer %>% distinct() %>% count(obj_parent)
keep_parents = count_parents[1][count_parents[2] > 1]
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
View(final_list)
#count occurences of parent objects
final_outer = distinct(final_outer)
count_parents = count(final_outer,obj_parent)
keep_parents = count_parents[1][count_parents[2] > 1]
#drop if object is only its own parent
final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
View(final_list)
table(berlin_only$kaufpreis)
?filter
View(test)
test %in% missings
is.na(berlin_only)
?is.na
berlin_only %in% missings
outer_dummy %in% missings
#subset by unique coordinate combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$amonths),]
outer_dummy %in% missings
missings %in% outer_dummy
outer_dummy %>% across(\(x)x %in% missings)
apply(outer_dummy,function(x) x %in% missings)
test = apply(outer_dummy,2,function(x) x %in% missings)
View(test)
View(outer_dummy)
test = apply(outer_dummy, 1 ,function(x) x %in% missings)
View(test)
test = apply(outer_dummy, 2 ,function(x) x %in% missings)
