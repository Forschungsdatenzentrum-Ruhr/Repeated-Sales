base::gc()
tar_make()
tar_make()
tar_make()
enquote()
enquote(test)
enquote("test")
tar_make_future(workers = 2)
tar_make_future(workers = 2)
tar_make_future(workers = 2)
tar_load(WK_classified)
tar_load(WK_prepared_repeated)
data_type = "WK"
tar_load_globals()
RED_classified = WK_classified
prepared_repeated = WK_prepared_repeated
make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss
#' @param RED_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
list_var
?lapply
fixed_effects <- list_var$fixed_effects
binary_names = list_var$binary_names
cont_names = list_var$cont_names
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
RED_classified
# reduce listings to only repeats and set missings to zero
pure_rs <- RED_classified[
hybrid_type == "repeat",
..var_to_keep
]
changed_boolean <- pure_rs[,
lapply(.SD, function(x) {
c(NA, diff(x))
}),
by = rs_id,
.SDcols = setdiff(var_to_keep, c("rs_id", "emonths", "depVar", "counting_id"))
][, rs_id := NULL] |> rowSums() != 0
RED_classified
str(RED_classified)
RED_classified <- prepare_hedonic(RED_classified, data_type)
prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tar_make()
tar_make_future(workers = 3)
tar_make()
tar_load_globals()
tar_load(WK_classified)
tar_load(WK_prepared_repeated)
tar_load_globals()
make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
head(ss)
options(warn = 0)
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss
?otions
?options
RED_classified = WK_classified
prepared_repeated = WK_prepared_repeated
data_type = "WK"
#' @param RED_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
fixed_effects <- list_var$fixed_effects
binary_names = list_var$binary_names
cont_names = list_var$cont_names
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tst = prepare_hedonic(RED_classified, data_type)
tst
#' @param RED_classified data.table. RED classified data.
#' @param data_type character. Type of data to be used. One of:
#' *WK = Wohnungskauf/ Apartments for sale
#' *WM = Wohnungsmiete/ Apartments for rent
#' *HK = Hauskauf/ Houses for sale
#'
#' @return data.table. Prepared hedonic index.
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(data_type, "character")
tar_assert_true(data_type %in% c("WK", "WM", "HK"), msg = "data_type must be one of WK, WM, HK")
#---------------------------------------------
if (data_type == "WK") {
prepared_hedonic <- make_hedonic_WK(RED_classified)
} else if (data_type == "WM") {
prepared_hedonic <- make_hedonic_WM(RED_classified)
} else if (data_type == "HK") {
prepared_hedonic <- make_hedonic_HK(RED_classified)
}
prepared_hedonic
#' @title Make Hedonic Index for WK
#'
#' @description Make the hedonic index for the WK data type
#' @param RED_classified data.table. Classified RED data
#'
#' @return data.table. Hedonic index for WK data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
# setup of regression
list_var <- make_var_list(data_type = "WK")
depVar <- list_var$depVar
indepVar <- list_var$indepVar
fixed_effects <- list_var$fixed_effects
# depVar prep
RED_classified[kaufpreis < 0, kaufpreis := 0]
RED_classified[, "ln_flatprice_sqm" := log(kaufpreis / wohnflaeche)]
tar_load_globals()
make_hybrid(WK_classified,WK_prepared_repeated, "WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated, "WK")
ss
tar_make_future(workers = 2)
library("targets")
tar_load_globals()
tar_visnetwork(T)
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_load(WK_classified)
tar_load(WK_prepared_repeated)
data_type = "WK"
RED_classified = WK_classified
prepared_repeated  =WK_prepared_repeated
#' @param RED_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
fixed_effects <- list_var$fixed_effects
binary_names <- list_var$binary_names
cont_names <- list_var$cont_names
indepVar = c(paste0("pre_", c(cont_names,binary_names)),paste0("sub_", c(cont_names,binary_names)))
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tar_assert_true(all(c("hybrid_type", "depVar") %in% names(RED_classified)), msg = "Missing variables")
# reduce listings to only repeats and set missings to zero
pure_rs <- RED_classified[
hybrid_type == "repeat",
..var_to_keep
]
changed_boolean <- pure_rs[,
lapply(.SD, function(x) {
c(NA, diff(x))
}),
by = rs_id,
.SDcols = setdiff(var_to_keep, c("rs_id", "emonths", "depVar", "counting_id"))
][, rs_id := NULL] |> rowSums() != 0
is.na(changed_boolean) <- FALSE
# Unit test
tar_assert_true(length(changed_boolean) == nrow(pure_rs), "Length of changed_boolean does not match pure_rs")
pure_rs[, changed_to := changed_boolean][, changed_from := lead(changed_to, 1), by = rs_id]
# this pretty much allows for duplicate indiviudal listings between pure/changed
# sample 1 pure rs
pure_pairs <- pure_rs[changed_to == FALSE | changed_from == FALSE]
View(head(pure_rs, n = 100))
tst = WK_classified[, rs_id == "1139458"]
tst = WK_classified[rs_id == "1139458"]
View(tst)
rm(RED_classified)
rm(WK_classified)
tar_load(WK_subset_classified)
RED_subset_classified = WK_subset_classified
View(head(RED_subset_classified, n = 100))
#' @param RED_subset_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_subset_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
fixed_effects <- list_var$fixed_effects
binary_names <- list_var$binary_names
cont_names <- list_var$cont_names
indepVar = c(paste0("pre_", c(cont_names,binary_names)),paste0("sub_", c(cont_names,binary_names)))
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
RED_subset_classified <- prepare_hedonic(RED_subset_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tar_assert_true(all(c("hybrid_type", "depVar") %in% names(RED_subset_classified)), msg = "Missing variables")
# reduce listings to only repeats and set missings to zero
pure_rs <- RED_subset_classified[
hybrid_type == "repeat",
..var_to_keep
]
View(pure_rs)
base::gc()
tar_make()
tar_make()
tar_make()
styler:::style_active_file()
styler:::style_active_file()
tar_make()
# without pure!
tar_make()
webshot::install_phantomjs()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
# testing
combined_hybrid = combined_hybrid[id_type %in% c("hedonic","changed")]
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
styler:::style_active_file()
tar_make()
log(0.5)
tar_make()
tar_make()
tar_load(WK_hybrid_index)
str(WK_hybrid_index)
tar_make()
?dplyr::complete
?complete
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_load_globals()
data_type = "WK"
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
fixed_effects <- list_var$fixed_effects
binary_names <- list_var$binary_names
cont_names <- list_var$cont_names
indepVar <- c(paste0("pre_", c(cont_names, binary_names)), paste0("sub_", c(cont_names, binary_names)))
#hybrid_regression <- feols_regression(combined_hybrid, indepVar, "Y", fixed_effects)
# construct regression formula
f = regression_function(indepVar, depVar)
rhs <- indepVar |> paste(collapse = " + ")
sprintf("%s ~ %s | %s", depVar, rhs, paste0(fixed_effects, collapse = "+"))
sprintf("%s ~ %s | %s", depVar, rhs, paste0(fixed_effects, collapse = "+")) |>
as.formula()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
?ggsave
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_load_globals()
debugSource("N:/FDZ/Intern/HiWi-Praktikanten/Mitarbeiter/Thorben/repeated offerings/R/make_/indicies_/make_hybrid.R")
tar_load(WK_subset_classified)
tar_load(wK_prepared_repeated)
tar_load(wK_prepared_repeated)
tar_load(WK_prepared_repeated)
data_type = "WK"
make_hybrid(WK_subset_classified, WK_prepared_repeated,"WK")
a = test_berlin[1:100]
b = berlin_ids[1:00]
b = berlin_ids[1:100]
View(c(a,b))
View(a)
View(a |> as.data.table())
View(as.data.table(a,b))
View(data.table(a,b))
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
f <- sprintf("%s ~ %s -1 ", depVar, rhs) |>
as.formula()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
tar_make()
suppressPackageStartupMessages({
# used during setup of pipeline
library(targets)
library(tarchetypes)
library(future)
library(future.callr)
library(fst)
library(renv)
library(rlang)
library(styler)
library(docstring)
library(jsonlite)
# used during execution of pipeline
library(MetBrewer)
library(here)
library(stringr)
library(dplyr)
library(tidyr)
library(data.table)
library(cli)
library(glue)
library(ggplot2)
library(haven)
library(modelsummary)
library(janitor)
library(kableExtra)
library(htmlTable)
library(fixest)
library(magrittr)
library(rsmatrix)
library(ggplot2)
library(qs)
library(scatterplot3d)
})
library("targets")
tar_make()
