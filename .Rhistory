inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
#update
) %>% mutate(
lead_time_diff = lead(time_diff)
)
View(inner_dummy)
lead(inner_dummy$time_diff)
gsub(NA,lead(inner_dummy$time_diff),""
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "1",
#.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "Inital",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
final_inner = inner_dummy %>% filter(!is.na(obj_parent) & !update_id == "2") %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,repeated_id,update_id,obj_parent,time_diff,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
694 402 633 358
table(final_list$repeated_id)
#5824292.09293933793584.658496123
#1.5 to 1 rooms
######################
#Cleanup
######################
rm(list = setdiff(setdiff(ls(),c("readpath","writepath","path")), lsf.str()))
gsub(NA,lead(inner_dummy$time_diff),"")
wk_data = read_dta(paste0(readpath,"WK_allVersionsLabels.dta"))
#shrink data to necessary
berlin_only =
wk_data %>%
filter(
# berlin
blid == 11,
# remove missings
as.character(lat_utm) != "-9",
as.character(lon_utm) != "-9",
na.rm = TRUE
) %>%
select(
obid,
uniqueID_gen,
mietekalt,
mietewarm,
kaufpreis,
wohnflaeche,
etage,
zimmeranzahl,
dupID_gen,
ajahr,
amonat,
ejahr,
emonat,
lat_utm,
lon_utm
) %>%
#new var
mutate(
latlon_utm = paste0(lat_utm,lon_utm),
#monat + 12 to avoid sorting issues in same year
ajahrmonat = paste0(ajahr,amonat+12),
ejahrmonat = paste0(ejahr,emonat+12)
)
rm(wk_data)
i = 5
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
######################
#Declarations
######################
#vars are allowed to deviate up to this factor in both directions
wohnflaeche_offset_factor = 0.1
etage_offset_factor = 99
zimmeranzahl_offset_factor = 0.5
time_offset_factor = 6
data_end_date = max(berlin_only$ejahrmonat)
final_list = c()
######################
#Section
######################
unique_latlon = unique(berlin_only$latlon_utm)
berlin_only$counting_id = 1:dim(berlin_only)[1]
#length(unique_latlon)
i = 5
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
printer(i,by = 10)
#print(i)
j = 1
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#repeated
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
lead_time_diff = lead(time_diff)
)
#extract inital offering
baseline = inner_dummy[1,]
#repeated
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
lead_time_diff = lead(time_diff)
)
#extract inital offering
baseline = inner_dummy[1,]
gsub(NA,lead(inner_dummy$time_diff),"")
?gsub
""
gsub(NA,"",lead(inner_dummy$time_diff))
lead(inner_dummy$time_diff)
sub(NA,"",lead(inner_dummy$time_diff))
?replace
#repeated
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
#time differences
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
td_to_end = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(data_end_date)),
td_to_lead = lead(base_time_diff)
)
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#extract inital offering
baseline = inner_dummy[1,]
#repeated
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
#time differences
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
td_to_end = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(data_end_date)),
td_to_lead = lead(base_time_diff)
)
#repeated
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
#time differences
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
td_to_end = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(data_end_date)),
td_to_lead = (as.numeric(inner_dummy$ajahrmonat) - lead(as.numeric(inner_dummy$ajahrmonat)))
)
View(inner_dummy)
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#print(i)
j = 1
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#length(unique_latlon)
i = 1
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#extract inital offering
baseline = inner_dummy[1,]
inner_dummy = inner_dummy %>% mutate(
##similarities
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
##time differences
#to inital offering
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
#to last date in data
td_to_end = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(data_end_date)),
#to preceding offering
td_to_lead = (as.numeric(inner_dummy$ajahrmonat) - lead(as.numeric(inner_dummy$ajahrmonat)))
)
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#extract inital offering
baseline = inner_dummy[1,]
inner_dummy = inner_dummy %>% mutate(
##similarities
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
##time differences
#to inital offering
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#to preceding offering
td_to_lead = (lead(as.numeric(inner_dummy$ajahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
)
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#extract inital offering
baseline = inner_dummy[1,]
inner_dummy = inner_dummy %>% mutate(
##similarities
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
##time differences
#to inital offering
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#to preceding offering
td_to_lead = (lead(as.numeric(inner_dummy$ejahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
)
replace(inner_dummy$td_to_lead,is.na(inner_dummy$td_to_lead),inner_dummy$td_to_end)
inner_dummy$td_to_lead[is.na(inner_dummy$td_to_lead)]
inner_dummy$td_to_lead[is.na(inner_dummy$td_to_lead),]
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#extract inital offering
baseline = inner_dummy[1,]
inner_dummy = inner_dummy %>% mutate(
##similarities
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
##time differences
#to inital offering
td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ejahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
)
is.na(inner_dummy$td_of_lead)
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)]
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
(lead(as.numeric(inner_dummy$ejahrmonat)) - c(as.numeric(inner_dummy$ajahrmonat),0))
replace_na(inner_dummy$td_of_lead,inner_dummy$td_to_end)
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
)
View(inner_dummy)
final_list = c()
#length(unique_latlon)
for(i in 1:100){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
printer(i,by = 10)
#print(i)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ejahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA)
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(wohnflaeche,etage,zimmeranzahl,counting_id,repeated_id,update_id,obj_parent,time_diff,latlon_utm)
#append to master and remove wohnflaeche subset array
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
#length(unique_latlon)
for(i in 1:100){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
printer(i,by = 10)
#print(i)
for(j in 1:length(unique_wohnflaeche)){
##subset by exact/range match in wohnflaeche
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
#cutoff all preceding offerings
#these cannot be repeated offerings since they were offered before candidate
inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
}
#Updates
######################
##gen time differences
inner_dummy = inner_dummy %>% mutate(
#to last date in data
td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
#of leading offering
td_of_lead = (lead(as.numeric(inner_dummy$ejahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
)
#replace last td_of_lead with td_to_end
inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]
#drops updates
inner_dummy = inner_dummy %>% filter(
.$td_of_lead >= as.numeric((time_offset_factor))
##intermediary cleanup
) %>% select(
#drop unused columns
-td_to_end
)
#Repeated
######################
#extract inital offering
baseline = inner_dummy[1,]
##gen similarity dummys
inner_dummy = inner_dummy %>% mutate(
#rooms
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
#floors
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
) %>% mutate(
##gen repeated indicator
repeated_id = case_when(
#is same offering
.$counting_id == baseline$counting_id ~ "0",
#both match; true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#floor matches, rooms similar; half-true repeated offering
#change to 1 later
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
#both are similar, resembling repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
),
##gen proposed object parent
obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA)
)
##final cleanup
final_inner = inner_dummy %>%
#drop offerings without parent
filter(!is.na(obj_parent)) %>%
#drop all colums but those of interest
select(counting_id,obj_parent,repeated_id,wohnflaeche,etage,zimmeranzahl,latlon_utm)
#append to master and remove wohnflaeche subset array
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
}
#remove unique coordination combination subset array
rm(outer_dummy)
}
final_list$obj_parent[i] %in% final_list$counting_id
final_list$obj_parent[1] == final_list$counting_id
sum(final_list$obj_parent[1] == final_list$counting_id)
sum(final_list$obj_parent[2] == final_list$counting_id)
sum(final_list$obj_parent[3] == final_list$counting_id)
sum(final_list$obj_parent[4] == final_list$counting_id)
sum(final_list$obj_parent[5] == final_list$counting_id)
sum(final_list$counting_id[5] == final_list$obj_parent)
sum(final_list$counting_id[1] == final_list$obj_parent)
sum(final_list$counting_id[2] == final_list$obj_parent)
