.SDcols = c("baujahr", "letzte_modernisierung")
][
# single mutations --------------------------------------------------------
# objektzustand
, ":="(
first_occupancy = fifelse(
objektzustand == 1, "Yes", "No"
),
# ausstattung
ausstattung = factor(
ausstattung,
0:4,
c(NA_character_, "Simple", "Normal", "Sophisticated", "Deluxe")
),
## etagen
# anzahletagen
num_floors = fcase(
anzahletagen <= 0, 0,
between(anzahletagen, 1, 3), 1,
between(anzahletagen, 4, 5), 2,
between(anzahletagen, 6, 10), 3,
anzahletagen > 10, 4
) |> factor(
0:4,
c(
NA_character_,
"1-3 floors",
"4-5 floors",
"6-10 floors",
"more than 10 floors"
)
),
# category etagen
cat_floors = fcase(
etage < 0, 0,
etage == 0, 1,
etage == 1, 2,
between(etage, 2, 3), 3,
between(etage, 4, 5), 4,
between(etage, 6, 10), 5,
anzahletagen > 10, 6
) |> factor(
0:6,
c(
NA_character_,
"ground floor (UG)",
"first floor (EG)",
"2nd to 3rd floor",
"4th to 5th floor",
"6th to 10th floor",
"above 10th floor"
)
),
# wohngeld
declared_wohngeld = fifelse(between(wohngeld, 0, 2500), "Yes", "No")
)
]
tar_assert_true(all(indepVar %in% names(RED_cleaned)))
return(RED_cleaned)
}
var_to_keep <- c(intersect(names(RED_classified), c(indepVar, depVar, fixed_effects)),"baujahr","letzte_modernisierung","objektzustand","anzahletagen","etage")
# clean data with procedure identical for all data_types
RED_cleaned <- all_type_cleaning(
# drop everything else to reduce RAM usage
RED_classified[, ..var_to_keep],
var_to_replace_missings = c(
"balkon",
"garten",
"einbaukueche",
"gaestewc",
"aufzug",
"keller",
"ausstattung",
"betreut"
),
indepVar
)
var_to_keep <- c(intersect(names(RED_classified), c(indepVar, depVar, fixed_effects)),"baujahr","letzte_modernisierung","objektzustand","anzahletagen","etage","wohngeld")
# clean data with procedure identical for all data_types
RED_cleaned <- all_type_cleaning(
# drop everything else to reduce RAM usage
RED_classified[, ..var_to_keep],
var_to_replace_missings = c(
"balkon",
"garten",
"einbaukueche",
"gaestewc",
"aufzug",
"keller",
"ausstattung",
"betreut"
),
indepVar
)
# drop extreme values of variables
#   * Apartment rents
# this is exclusive in REDX and inclusive here
upper_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], 1 - (0.5 / 100))
lower_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], (0.5 / 100))
var_to_keep <- c(intersect(names(RED_classified), c(indepVar, depVar, fixed_effects)),"baujahr","letzte_modernisierung","objektzustand","anzahletagen","etage","wohngeld","wohnflaeche","kaufpreis")
# clean data with procedure identical for all data_types
RED_cleaned <- all_type_cleaning(
# drop everything else to reduce RAM usage
RED_classified[, ..var_to_keep],
var_to_replace_missings = c(
"balkon",
"garten",
"einbaukueche",
"gaestewc",
"aufzug",
"keller",
"ausstattung",
"betreut"
),
indepVar
)
# drop extreme values of variables
#   * Apartment rents
# this is exclusive in REDX and inclusive here
upper_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], 1 - (0.5 / 100))
lower_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], (0.5 / 100))
RED_filtered <- RED_cleaned[
zimmeranzahl < 8 &
kaufpreis %between% c(0, 2000000) &
wohnflaeche %between% c(lower_percentile, upper_percentile)
]
depVar <- "ln_flatprice_sqm"
indepVar <- c(
# cleaned/created during all_type_cleaning
"baujahr_cat",
"first_occupancy",
"balkon",
"garten",
"einbaukueche",
"gaestewc",
"zimmeranzahl",
"aufzug",
"keller",
"ausstattung",
"betreut",
"declared_wohngeld",
"num_floors",
"cat_floors"
)
fixed_effects <- c("kid2019", "ejahr")
# depVar ------------------------------------------------------------------
RED_classified[, "ln_flatprice_sqm" := log(kaufpreis / wohnflaeche)]
var_to_keep <- c(intersect(names(RED_classified), c(indepVar, depVar, fixed_effects)),"baujahr","letzte_modernisierung","objektzustand","anzahletagen","etage","wohngeld","wohnflaeche","kaufpreis")
# clean data with procedure identical for all data_types
RED_cleaned <- all_type_cleaning(
# drop everything else to reduce RAM usage
RED_classified[, ..var_to_keep],
var_to_replace_missings = c(
"balkon",
"garten",
"einbaukueche",
"gaestewc",
"aufzug",
"keller",
"ausstattung",
"betreut"
),
indepVar
)
# drop extreme values of variables
#   * Apartment rents
# this is exclusive in REDX and inclusive here
upper_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], 1 - (0.5 / 100))
lower_percentile <- quantile(RED_cleaned[wohnflaeche >= 0, wohnflaeche], (0.5 / 100))
RED_filtered <- RED_cleaned[
zimmeranzahl < 8 &
kaufpreis %between% c(0, 2000000) &
wohnflaeche %between% c(lower_percentile, upper_percentile)
]
rhs <- indepVar |> paste(collapse = " + ")
f <- sprintf("%s ~ %s | %s", depVar, rhs, paste0(fixed_effects, collapse = "^")) |>
as.formula()
hedonic_WK <- feols(f, RED_filtered, combine.quick = F, mem.clean = T)
summary(hedonic_WK)
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
tar_load(classification)
vars_needed = c("parent","emonths","kaufpreis")
rs_pairs = classfication[..vars_needed]
rs_pairs = classification[..vars_needed]
rs_pairs = classification[,..vars_needed]
vars_needed = c("parent","emonths","p_var")
rs_pairs = classification[,..vars_needed]
vars_needed = c("parent","emonths","price_var")
rs_pairs = classification[,..vars_needed]
duplicated(rs_pairs)
vars_needed = c("parent","emonths","kaufpreis","kid2019")
rs_pairs = classification[,..vars_needed]
vars_needed = c("parent","emonths","kaufpreis","latlon_utm")
rs_pairs = classification[,..vars_needed]
#vars_needed = c("parent","emonths","kaufpreis","latlon_utm")
vars_needed = c("parent","emonths","price_var","latlon_utm")
rs_pairs = classification[,..vars_needed]
duplicated(rs_pairs)
head(rs_pairs)
tst = rs_pairs[rs_pairs, on = "parent"]
tst = rs_pairs[rs_pairs, on = "parent", allow.cartesian = T]
head(tst)
?data.table
tst = rs_pairs[rs_pairs, on = c("parent" == "parent","emonths"!="emonths"), allow.cartesian = T]
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths!=emonths"), allow.cartesian = T]
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths"), allow.cartesian = T]
head(tst)
#vars_needed = c("parent","emonths","kaufpreis","latlon_utm")
vars_needed = c("parent","emonths","price_var")
rs_pairs = classification[,..vars_needed]
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths")]
head(tst)
#vars_needed = c("counting_id","parent","emonths","kaufpreis","latlon_utm")
vars_needed = c("parent","emonths","price_var")
#vars_needed = c("counting_id","parent","emonths","kaufpreis","latlon_utm")
vars_needed = c("counting_id","parent","emonths","price_var")
rs_pairs = classification[,..vars_needed]
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths")]
head(tst)
a = rs_pairs[parent == 52895]
View(a)
a = classification[parent == 52895]
View(a)
rs_pairs = classification[non_list_reason == "Sold",..vars_needed]
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths")]
head(tst)
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths"), nomatch =0]
head(tst)
head(rs_pairs)
a = classification[parent == 52895]
View(rs_pairs)
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths"), nomatch =0]
head(tst)
a = rs_pairs[parent == 3203]
View(a)
tst = rs_pairs[rs_pairs, on = c("parent==parent","emonths>emonths"), nomatch =0, suffix = "prev"]
tst = rs_pairs[rs_pairs, on = c("parent==parent"), nomatch =0, suffix = "prev"]
tst = rs_pairs[rs_pairs, on = c("parent==parent"), nomatch =0]
head(tst)
self_merged_rs_pairs = rs_pairs[rs_pairs, on = c("parent==parent"), nomatch =0]
?merge.data.table
keys(rs_pairs)
key(rs_pairs)
setkey(rs_pairs,"parent")
key(rs_pairs)
prev_cols = setdiff(intersect(rs_pairs,rs_pairs),"parent")
prev_cols = setdiff(intersect(names(rs_pairs),names(rs_pairs)),"parent")
?setnames
setnames(self_merged_rs_pairs,glue::glue("i.{prev_cols}", glue::glue("prev_{prev_cols}")
self_merged_rs_pairs = rs_pairs[rs_pairs, on = c("parent==parent"), nomatch =0]
setnames(self_merged_rs_pairs,glue::glue("i.{prev_cols}", glue::glue("prev_{prev_cols}"))
?setnames
self_merged_rs_pairs[]
}
self_merged_rs_pairs = rs_pairs[rs_pairs, on = c("parent==parent"), nomatch =0]
setnames(self_merged_rs_pairs,glue::glue("i.{prev_cols}"), glue::glue("prev_{prev_cols}"))
self_merged_rs_pairs
?data.table
?as.Date
?yearmon
?as.date
?as.Date
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, .(
year = emonths %/% 12,
month = (emonths / 12) - (emonths %/% 12)
)]
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, .(
year = emonths %/% 12,
month = emonths - ((emonths %/% 12)*12)
)]
rs_pairs[, .(
year = emonths %/% 12,
month = emonths - ((emonths %/% 12)*12)
) |> paste0(year,"-",month, "-01") |> as.Date(format = "YYYY-MM-DD")
]
styler:::style_active_file()
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, date := paste0(
# years in format YYYY
emonths %/% 12,
"-",
# months in format MM
emonths - ((emonths %/% 12) * 12),
"-01"
) |> as.Date(format = "YYYY-MM-DD")]
rs_pairs
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, date := paste0(
# years in format YYYY
emonths %/% 12,
"-",
# months in format MM
emonths - ((emonths %/% 12) * 12),
"-01"
) |> as.Date(format = "%Y-%M-%D")]
rs_pairs
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, date := paste0(
# years in format YYYY
emonths %/% 12,
"-",
# months in format MM
emonths - ((emonths %/% 12) * 12),
"-01"
) #|> as.Date(format = "%Y-%M-%D")
]
rs_pairs
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, sprintf(
"%d-%02d-01",
emonths %/% 12,
emonths - ((emonths %/% 12) * 12)
)
]
rs_pairs[, sprintf(
"%d-%02d-01",
emonths %/% 12,
emonths - ((emonths %/% 12) * 12)
) |> as.Date(format = "%Y-%m-%d")
]
tst_a = 2015 * 12 + 5
tst_a%/%12
tst_a = 2015 * 12 + 1
tst_a%/%12
tst_a _ tst_a%/%12
tst_a - tst_a%/%12
tst_a - tst_a%/%12*12
tst_a = 2015 * 12 + 12
tst_a - tst_a%/%12*12
rs_pairs[, sprintf(
"%d-%02d-01",
emonths %/% 12,
emonths - ((emonths %/% 12) * 12)
)
]
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)]
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)][
month == 0, ":="(month = 12, year = year -1)
]
rs_pairs
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)][
month == 0, .(month = 12, year = year -1)
]
rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)]
# reverse year to month conversion done during initial reading
# since functions require dates
ym_tst = rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)][
month == 0, .(month = 12, year = year -1)
]
ym_tst
# reverse year to month conversion done during initial reading
# since functions require dates
ym_tst = rs_pairs[, .(month = emonths - ((emonths %/% 12) * 12), year = emonths %/% 12)][
month == 0, ":="(month = 12, year = year -1)
]
ym_tst
head(ym_tst)
year_months[,"year"]
# reverse year to month conversion done during initial reading
# since functions require dates
year_months = rs_pairs[, .(year = emonths %/% 12, month = emonths - ((emonths %/% 12) * 12))][
month == 0, ":="(month = 12, year = year -1)
]
year_months[,"year"]
rs_pairs[, sprintf(
"%d-%02d-01",
year_months[,"year"],
year_months[,"month"]
)
]
year_months[,"year", with = T]
year_months[,"year", with = F]
class(year_months[,"year", with = T])
class(year_months[,"year", with = F])
as.numeric(year_months[,"year"])
as.numeric(year_months[,"year", with = F])
as.numeric(year_months[,"year", with = T])
year_months[,"year"] |>  pull()
year_months[["year"]]
# reverse year to month conversion done during initial reading
# since functions require dates
rs_pairs[, ":="(year = emonths %/% 12, month = emonths - ((emonths %/% 12) * 12))][
month == 0, ":="(month = 12, year = year -1)
]
rs_pairs
unique(rs_pairs[["month"]])
unique(rs_pairs[["year"]])
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
renv::install("rsmatrix")
library(rsmatrix)
# drop merges made on exact same listing
# taken from rsmatrix vignette
matrices = with(
self_merged_rs_pairs[counting_id != prev_counting_id],
rs_matrix(date,prev_date,price_var, prev_price_var, sparse = T)
)
vars_needed <- c("counting_id", "parent", "emonths", "price_var")
rs_pairs <- classification[non_list_reason == "Sold", ..vars_needed]
setkey(rs_pairs, "parent")
# reverse year to month conversion done during initial reading since subsequent functions require dates
rs_pairs[
, ":="(
year = emonths %/% 12,
month = emonths - ((emonths %/% 12) * 12)
)
][
# december is converted to an additional year, is this already a problem before this?
# maybe use yearmon from zoo instead, shouldnt be a big change
month == 0,
":="(
month = 12,
year = year - 1
)
]
rs_pairs[, ":="(
# sprintf is used to pad leading zeros for months while pasteing at the same time
# %d means digits
# %02d means digit with leading zeros until length 2
date = sprintf(
"%d-%02d-01",
year,
month
) |>  as.Date(format = "%Y-%m-%d"),
# drop year + month columns
year = NULL,
month = NULL,
emonths = NULL
)]
# extract columns whose names are getting i. prefix during self-merge
prev_cols <- setdiff(intersect(names(rs_pairs), names(rs_pairs)), "parent")
# self-merge data to construct required data structure
self_merged_rs_pairs <- rs_pairs[rs_pairs, on = c("parent==parent"), nomatch = 0]
# rename columns for clarity
setnames(self_merged_rs_pairs, glue::glue("i.{prev_cols}"), glue::glue("prev_{prev_cols}"))
# drop merges made on exact same listing
# taken from rsmatrix vignette
matrices = with(
self_merged_rs_pairs[counting_id != prev_counting_id],
rs_matrix(date,prev_date,price_var, prev_price_var, sparse = T)
)
self_merged_rs_pairs[counting_id != prev_counting_id]
# drop merges made on exact same listing
# taken from rsmatrix vignette
matrices = with(
self_merged_rs_pairs[counting_id != prev_counting_id & date > prev_date],
rs_matrix(date,prev_date,price_var, prev_price_var, sparse = T)
)
Z = matrices("Z")
head(Z)
View(Z)
Z@x
y = matrices("y")
grs = exp(solve(crossprod(Z), crossprod(Z,y)))
y
self_merged_rs_pairs[
counting_id != prev_counting_id &
date > prev_date &
price_var != prev_price_var
]
log(1)
self_merged_rs_pairs[
# listings merged on themselves
counting_id != prev_counting_id &
# opposite shouldnt be occuring, have to check
date > prev_date &
# price = 0 throws error
(price_var == 0| prev_price_var == 0)
]
matrices = with(
self_merged_rs_pairs[
# listings merged on themselves
counting_id != prev_counting_id &
# opposite shouldnt be occuring, have to check
date > prev_date &
# price = 0 throws error
(price_var != 0 & prev_price_var != 0)
]
self_merged_rs_pairs[
# listings merged on themselves
counting_id != prev_counting_id &
# opposite shouldnt be occuring, have to check
date > prev_date &
# price = 0 throws error
(price_var != 0 & prev_price_var != 0)
]
styler:::style_active_file()
