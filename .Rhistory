price = c(1, 3, 2,1,1,13))
dx[c("date_prev","price_prev")] = dx[rs_pairs(dx$date,dx$id),c("date","price")]
dx = subset(dx,date > date_prev)
matrix_const = with(dx, rs_matrix(date,date_prev,price,price_prev))
Z <- matrix_const("Z")
y <- matrix_const("y")
X <- matrix_const("X")
Y <- matrix_const("Y")
grs_b <- qr.coef(qr(Z), y) |> setdiff(NA)
GRS <- (exp(grs_b) * 100) |> formatC(format = "f", digits = 4)
dt_GRS = data.table(date = names(GRS), GRS = GRS)
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
)
dx <- data.frame(id = c(1, 1, 1,2,2,2),
date = c(1, 2, 3,4,5,11),
price = c(1, 3, 2,1,1,13))
dx[c("date_prev","price_prev")] = dx[rs_pairs(dx$date,dx$id),c("date","price")]
dx = subset(dx,date > date_prev)
matrix_const = with(dx, rs_matrix(date,date_prev,price,price_prev))
dx
dx <- data.frame(id = c(1, 1, 1,2,2,2),
date = c(1, 2, 3,4,5,11),
price = c(1, 3, 2,1,1,13))
dx
dx[c("date_prev","price_prev")] = dx[rs_pairs(dx$date,dx$id),c("date","price")]
dx = subset(dx,date > date_prev)
dx
matrix_const = with(dx, rs_matrix(date,date_prev,price,price_prev))
rs_matrix
dx
matrix_const = with(dx, rs_matrix(date,date_prev,price,price_prev))
Z <- matrix_const("Z")
y <- matrix_const("y")
X <- matrix_const("X")
Y <- matrix_const("Y")
grs_b <- qr.coef(qr(Z), y) |> setdiff(NA)
GRS <- (exp(grs_b) * 100) |> formatC(format = "f", digits = 4)
dt_GRS = data.table(date = names(GRS), GRS = GRS)
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
) |> setdiff(NA)
qr(t(Z) %*% X)
t(Z) %*% Y
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
)
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
) |> setdiff(NA)
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
)
ars_b
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
) |> setdiff(NA)
ars_b
?setdiff
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
) |> na.omit()
100/0
is.finite(100/0)
ars_b[ars_b == 0] = NA
ARS = (100 / ars_b)|> formatC(format = "f", digits = 4)
dt_ARS = data.table(date = rownames(ars_b),ars_b = ars_b, ARS = ARS)
repeated_indices = dt_GRS[dt_ARS, on = "date"] |>  drop_na()
tar_make()
tar_load(repeated_index )
View(repeated_index)
# used during setup of pipeline
req_library <- c(
"targets",
"tarchetypes",
"future",
"future.callr",
"fst",
"renv",
"rlang",
"styler",
"docstring"
)
# used during execution of pipeline
pipeline_library <- c(
"here",
"stringr",
"dplyr",
"tidyr",
"data.table",
"cli",
"glue",
"ggplot2",
"haven", # reading/writing of dta files
"tidyverse", # data manipulation/wrangeling
"magrittr", # two sided pipe
"fst", #
"modelsummary",
"janitor",
"htmlTable"
)
suppressPackageStartupMessages({
# used during setup of pipeline
library(targets)
library(tarchetypes)
library(future)
library(future.callr)
library(fst)
library(renv)
library(rlang)
library(styler)
library(docstring)
library(jsonlite)
# used during execution of pipeline
library(MetBrewer)
library(here)
library(stringr)
library(dplyr)
library(tidyr)
library(data.table)
library(cli)
library(glue)
library(ggplot2)
library(haven)
library(modelsummary)
library(janitor)
library(kableExtra)
library(htmlTable)
library(fixest)
library(magrittr)
library(rsmatrix)
library(ggplot2)
library(qs)
})
styler:::style_active_file()
?  out <- hedonic_regression(
RED_data = RED_HK,
indepVar = indepVar,
depVar = depVar,
fixed_effects = fixed_effects
)
?fixef
tar_make()
tar_load(self_merged_rs_pairs)
View(self_merged_rs_pairs)
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = grouping_var,
sparse = F
)
)
grouping_var = "blid"
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = grouping_var,
sparse = F
)
)
?sub
?eval
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = !!!grouping_var,
sparse = F
)
)
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = !!grouping_var,
sparse = F
)
)
?with
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = eval(grouping_var),
sparse = F
)
)
eval(grouping_var)
substitute(grouping_var)
eval(substitute(grouping_var))
eval(!!substitute(grouping_var))
unquote(substitute(grouping_var))
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = {{grouping_var}},
sparse = F
)
)
enquo(grouping_var)
as.name(grouping_var)
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = as.name(grouping_var),
sparse = F
)
)
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
# na.omit here since update joins ignore nomatch = 0 argument
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = eval(parse(grouping_var)),
sparse = F
)
)
do.call(grouping_var)
# taken from rsmatrix vignette
# see also ?rs_matrix
matrices <- with(
self_merged_rs_pairs,
rs_matrix(
t2 = date,
t1 = prev_date,
p2 = price_var,
p1 = prev_price_var,
f = eval(as.symbol(grouping_var)),
sparse = F
)
)
Z <- matrices("Z")
y <- matrices("y")
X <- matrices("X")
Y <- matrices("Y")
# GRS ---------------------------------------------------------------------
# index via Bailey(1963)
grs_b <- qr.coef(qr(Z), y) |> na.omit()
GRS <- (exp(grs_b) * 100) |> formatC(format = "f", digits = 4)
dt_GRS = data.table(date = names(GRS), GRS = GRS)
# index via Shiller (1991)
ars_b <- qr.coef(
qr(t(Z) %*% X),
t(Z) %*% Y
) |> na.omit()
# this helps the divide by zero issue but is still kinda weird
# doesnt fix the weird values
ars_b[ars_b == 0] = NA
ARS = (100 / ars_b)|> formatC(format = "f", digits = 4)
dt_ARS = data.table(date = rownames(ars_b),ars_b = ars_b, ARS = ARS)
# combined ----------------------------------------------------------------
repeated_indices = dt_GRS[dt_ARS, on = "date"] |>  drop_na()
return(repeated_indices)
View(repeated_indices)
View(self_merged_rs_pairs)
options(error = traceback)
# used during setup of pipeline
req_library <- c(
"targets",
"tarchetypes",
"future",
"future.callr",
"fst",
"renv",
"rlang",
"styler",
"docstring"
)
# used during execution of pipeline
pipeline_library <- c(
"here",
"stringr",
"dplyr",
"tidyr",
"data.table",
"cli",
"glue",
"ggplot2",
"haven", # reading/writing of dta files
"tidyverse", # data manipulation/wrangeling
"magrittr", # two sided pipe
"fst", #
"modelsummary",
"janitor",
"htmlTable"
)
renv::install("plotly")
library(plotly)
## load example data
tar_load(example_markdown_data)
suppressPackageStartupMessages({
# used during setup of pipeline
library(targets)
library(tarchetypes)
library(future)
library(future.callr)
library(fst)
library(renv)
library(rlang)
library(styler)
library(docstring)
library(jsonlite)
# used during execution of pipeline
library(MetBrewer)
library(here)
library(stringr)
library(dplyr)
library(tidyr)
library(data.table)
library(cli)
library(glue)
library(ggplot2)
library(haven)
library(modelsummary)
library(janitor)
library(kableExtra)
library(htmlTable)
library(fixest)
library(magrittr)
library(rsmatrix)
library(ggplot2)
library(qs)
library(plotly)
})
## load example data
tar_load(example_markdown_data)
tar_load(example_markdown_data)
# show head
head(example_markdown_data)
# show summary
summary(example_markdown_data)
# these are globally defined in _targets.R
print(exportJSON)
# make color blind friendly palette
etage_colors = MetBrewer::met.brewer("Egypt", n = uniqueN(example_markdown_data$etage))
plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
# make color blind friendly palette
etage_colors = MetBrewer::met.brewer("Egypt", n = uniqueN(example_markdown_data$etage))
plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
options(error = traceback)
# used during setup of pipeline
req_library <- c(
"targets",
"tarchetypes",
"future",
"future.callr",
"fst",
"renv",
"rlang",
"styler",
"docstring"
)
# used during execution of pipeline
pipeline_library <- c(
"here",
"stringr",
"dplyr",
"tidyr",
"data.table",
"cli",
"glue",
"ggplot2",
"haven", # reading/writing of dta files
"tidyverse", # data manipulation/wrangeling
"magrittr", # two sided pipe
"fst", #
"modelsummary",
"janitor",
"htmlTable"
)
suppressPackageStartupMessages({
# used during setup of pipeline
library(targets)
library(tarchetypes)
library(future)
library(future.callr)
library(fst)
library(renv)
library(rlang)
library(styler)
library(docstring)
library(jsonlite)
# used during execution of pipeline
library(MetBrewer)
library(here)
library(stringr)
library(dplyr)
library(tidyr)
library(data.table)
library(cli)
library(glue)
library(ggplot2)
library(haven)
library(modelsummary)
library(janitor)
library(kableExtra)
library(htmlTable)
library(fixest)
library(magrittr)
library(rsmatrix)
library(ggplot2)
library(qs)
library(plotly)
})
tar_load(example_markdown_data)
tar_load(example_markdown_data)
fig1 = plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
etage_colors = MetBrewer::met.brewer("Egypt", n = uniqueN(example_markdown_data$etage))
fig1 = plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
plotly::kaleido(fig1)
fig1 = plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
fig1.show()
fig1
## load example data
tar_load(example_markdown_data)
# make color blind friendly palette
etage_colors = MetBrewer::met.brewer("Egypt", n = uniqueN(example_markdown_data$etage))
fig1 = plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
rglwidget(fig1)
renv::install("reticulate ")
renv::install("reticulate")
# make color blind friendly palette
etage_colors = MetBrewer::met.brewer("Egypt", n = uniqueN(example_markdown_data$etage))
fig1 = plot_ly(example_markdown_data, x = ~wohnflaeche, y = ~zimmeranzahl, z = ~etage, colors = etage_colors) |> add_markers() |> layout(scene = list(
xaxis = list(title = "Wohnflaeche"),
yaxis = list(title = "Zimmeranzahl"),
zaxis = list(title = "Etage")
))
plotly::kaleido(fig1)
reticulate::py_available()
