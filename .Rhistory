clustering$centers
clustering_centers = clustering$centers
# unique deals with a parent being chosen as such from multiple listings
# since the parent is the same either way, no special consideration is necessary
# TODO: consider dropping NAs in sim_index here aswell since these should never be chosen
competing_parents <- unique(clustering_centers)[, .SD[.N >= 2], by = "counting_id"]
View(competing_parents)
# setup and run the actual clustering
clustering <- cluster$new(
cluster_options = similarity_index_list,
distance = similarity_dist_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
# setup and run the actual clustering
clustering <- cluster$new(
cluster_options = similarity_index_list,
distance = similarity_dist_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
View(clustering)
View(similarity_dist_list)
View(similarity_index_list)
View(competing_parents)
# unique deals with a parent being chosen as such from multiple listings
# since the parent is the same either way, no special consideration is necessary
# TODO: consider dropping NAs in sim_index here aswell since these should never be chosen
competing_parents <- unique(clustering_centers)[, .SD[.N >= 2], by = "counting_id"]
# parent vs parent competing:
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[, .SD[which.min(sim_dist)], by = "counting_id"]
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competiton and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[parent != counting_id]
View(parent_parent_winners)
View(parent_parent_competitors)
View(competing_parents)
# parent vs parent competing:
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[, .SD[which.min(sim_dist)], by = "counting_id"]
# clean_up of NAs:
na_parent_competitors = competing_parents[, is.na(sim_index)]
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index)]
View(na_parent_competitors)
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index), on = "counting_id"]
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index)][competing_parents, on = "counting_id"]
View(na_parent_competitors)
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index)][.(competing_parents), on = "counting_id"]
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index)]
# clean_up of NAs:
na_parent_competitors = competing_parents[is.na(sim_index)]$counting_id
na_parent_winners = na_parent_competitors[competing_parents, on = "counting_id"]
na_parent_winners = competing_parents[.(na_parent_competitors), on = "counting_id"]
View(na_parent_winners)
styler:::style_selection()
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
na_parent_winners <- competing_parents[
.(na_parent_competitors),
on = "counting_id"
][
, .SD[which.min(sim_dist)],
by = "counting_id"
]
View(na_parent_winners)
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
competing_parents <- clustering_centers[
, .SD[.N >= 2],
by = "counting_id"
]
View(competing_parents)
# isolate cases where conflicts arose
# unique deals with a parent being chosen as such from multiple listings
# since the parent is the same either way, no special consideration is necessary
competing_parents <- unique(clustering_centers)[
, .SD[.N >= 2],
by = "counting_id"
]
# find wrongfully chosen counting_ids
# for fully explanation of why/how this occurs refer to cluster_class.R
na_parent_ids <- competing_parents[
is.na(sim_index)
]$counting_id
na_parent_competitors <- competing_parents[
.(na_parent_ids),
on = "counting_id"
]
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
na_parent_winners
# find wrongfully chosen counting_ids
# for fully explanation of why/how this occurs refer to cluster_class.R
na_parent_ids <- competing_parents[
is.na(sim_index)
]$counting_id
na_parent_competitors <- competing_parents[
.(na_parent_ids),
on = "counting_id"
]
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# keep only non-na_parent_winners for further considerations
competing_parents <- rbindlist(
competing_parents[
!is.na(sim_index)
],
na_parent_winners
)
?rbindlist
# isolate cases where conflicts arose
# unique deals with a parent being chosen as such from multiple listings
# since the parent is the same either way, no special consideration is necessary
competing_parents <- unique(clustering_centers)[
, .SD[.N >= 2],
by = "counting_id"
]
# find wrongfully chosen counting_ids
# for fully explanation of why/how this occurs refer to cluster_class.R
na_parent_ids <- competing_parents[
is.na(sim_index)
]$counting_id
na_parent_competitors <- competing_parents[
.(na_parent_ids),
on = "counting_id"
]
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# keep only non-na_parent_winners for further considerations
competing_parents <- rbindlist(
.(
competing_parents[
!is.na(sim_index)
],
na_parent_winners
)
)
# keep only non-na_parent_winners for further considerations
competing_parents <- rbindlist(
rlang::list2(
competing_parents[
!is.na(sim_index)
],
na_parent_winners
)
)
View(competing_parents)
# isolate cases where conflicts arose
# unique deals with a parent being chosen as such from multiple listings
# since the parent is the same either way, no special consideration is necessary
a_competing_parents <- unique(clustering_centers)[
, .SD[.N >= 2],
by = "counting_id"
]
View(a_competing_parents)
styler:::style_active_file()
# keep only non-na_parent_winners for further considerations
competing_parents <- unique(
rbindlist(
rlang::list2(
competing_parents[
!is.na(sim_index)
],
na_parent_winners
)
)
)
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
View(parent_parent_competitors)
# keep only non-na_parent_winners for further considerations
competing_parents <- unique(
rbindlist(
rlang::list2(
competing_parents[
!is.na(sim_index)
],
na_parent_winners
)
)
)
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
View(competing_parents)
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
View(parent_parent_winners)
View(competing_parents)
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
## first option: x parent of cluster x with children y_n -> gain = sum(similiarity of children)
parent_children_ids <- parent_parent_competitors[
parent == counting_id
]$parent
parent_children_competitors <- clustering_centers[
.(parent_children_ids),
on = "parent"
]
parent_gains <- parent_children_competitors[,
.("cluster_sim_dist" = sum(sim_dist)),
by = "parent",
]
child_parent_competitors <- clustering_centers[
.(parent_children_ids),
on = "counting_id"
]
child_gains <- child_parent_competitors[
!.(parent_children_ids),
.("counting_id" = counting_id, "single_sim_dist" = sim_dist),
on = "parent"
]
gains_comparison <- parent_gains[
child_gains,
"winner" := fifelse(
cluster_sim_dist >= single_sim_dist, "parent", "child"
),
on = .(parent == counting_id)
]
View(gains_comparison)
unique_clustering_centers = unique(clustering_centers)
# find wrongfully chosen counting_ids
# for fully explanation of why/how this occurs refer to cluster_class.R
na_parent_ids <- unique_clustering_centers[
is.na(sim_index)
]$counting_id
na_parent_competitors <- unique_clustering_centers[
.(na_parent_ids),
on = "counting_id"
]
View(na_parent_competitors)
?which.min
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
View(na_parent_winners)
na_parent_ids <- unique_clustering_centers[
is.na(sim_index)
]$counting_id
na_parent_competitors <- unique_clustering_centers[
.(na_parent_ids),
on = "counting_id"
]
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# keep only non-na_parent_winners for further considerations
unique_clustering_centers <- unique(
rbindlist(
rlang::list2(
unique_clustering_centers[
!is.na(sim_index)
],
na_parent_winners
)
)
)
unique_clustering_centers = unique(clustering_centers)
# each observation can only be a parent or child, never both
# to dissolve this conflict compare similiarity gains from each case
# unique deals with a parent being chosen as such from multiple cluster
# since the parent is the same either way, no special consideration is necessary
unique_clustering_centers = unique(clustering_centers)
# find wrongfully chosen counting_ids
na_parent_ids <- unique_clustering_centers[
is.na(sim_index)
]$counting_id
# isolate competitors based on ids
na_parent_competitors <- unique_clustering_centers[
.(na_parent_ids),
on = "counting_id"
]
# compare competitors and chose winners
na_parent_winners <- na_parent_competitors[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# keep only non-na_parent_winners for further considerations
unique_clustering_centers <- unique(
rbindlist(
rlang::list2(
unique_clustering_centers[
!is.na(sim_index)
],
na_parent_winners
)
)
)
# isolate cases where conflicts arose
competing_parents <- unique_clustering_centers[
, .SD[.N >= 2],
by = "counting_id"
]
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
, .SD[which.min(sim_dist)],
by = "counting_id"
]
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
View(parent_parent_winners)
View(parent_parent_competitors)
View(competing_parents)
## first option: x parent of cluster x with children y_n -> gain = sum(similiarity of children)
parent_children_ids <- parent_parent_competitors[
parent == counting_id
]$parent
parent_children_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "parent"
]
parent_gains <- parent_children_competitors[,
.("cluster_sim_dist" = sum(sim_dist)),
by = "parent",
]
child_parent_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "counting_id"
]
child_gains <- child_parent_competitors[
!.(parent_children_ids),
.("counting_id" = counting_id, "single_sim_dist" = sim_dist),
on = "parent"
]
## first option: x parent of cluster x with children y_n -> gain = sum(similiarity of children)
parent_children_ids <- parent_parent_competitors[
parent == counting_id
]$parent
styler:::style_active_file()
length(parent_children_ids)
length(competing_parents)
styler:::style_active_file()
styler:::style_active_file()
styler:::style_active_file()
# keep only non-NAs for further considerations
unique_clustering_centers <-
unique_clustering_centers[
!is.na(sim_index)
]
styler:::style_active_file()
# isolate cases where conflicts arose
competing_parents <- unique_clustering_centers[
,
.SD[.N >= 2],
by = "counting_id"
]
# unique deals with a parent being chosen as such from multiple cluster
# since the parent is the same either way, no special consideration is necessary
unique_clustering_centers <- unique(clustering_centers)
# keep only non-NAs for further considerations
unique_clustering_centers <- unique_clustering_centers[
!is.na(sim_index)
]
# isolate cases where conflicts arose
competing_parents <- unique_clustering_centers[
,
.SD[.N >= 2],
by = "counting_id"
]
# check if cleaning up Nas fixed the problem already
if (length(competing_parents) != 0) {
# parent vs parent competing ----------------------------------------------
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
,
.SD[which.min(sim_dist)],
by = "counting_id"
]
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
# parent vs child competing -----------------------------------------------
# find parents which have conflicting classifications
parent_children_ids <- parent_parent_competitors[
parent == counting_id
]$parent
if (length(parent_children_ids) != 0) {
## first option: x parent of cluster x with children y_n -> gain = sum(similiarity of children)
# isolate competitors based on ids
parent_children_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "parent"
]
# calculate gains of being x being a parent
parent_gains <- parent_children_competitors[
,
.("cluster_sim_dist" = sum(sim_dist)),
by = "parent",
]
## second option: x child of cluster z -> gain = similarity to parent
# isolate competitors based on ids
child_parent_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "counting_id"
]
child_gains <- child_parent_competitors[
!.(parent_children_ids),
.("counting_id" = counting_id, "single_sim_dist" = sim_dist),
on = "parent"
]
# Compare gains
gains_comparison <- parent_gains[
child_gains,
"winner" := fifelse(
cluster_sim_dist >= single_sim_dist, "parent", "child"
),
on = .(parent == counting_id)
]
}
}
length(competing_parents)
# x is potential child of y or z but not itself -> choose lowest sim_dist
# this also contains all listings with are their own parent -> used in first option
parent_parent_competitors <- competing_parents[
,
.SD[which.min(sim_dist)],
by = "counting_id"
]
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
# find parents which have conflicting classifications
parent_children_ids <- parent_parent_competitors[
parent == counting_id
]$parent
if (length(parent_children_ids) != 0) {
## first option: x parent of cluster x with children y_n -> gain = sum(similiarity of children)
# isolate competitors based on ids
parent_children_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "parent"
]
# calculate gains of being x being a parent
parent_gains <- parent_children_competitors[
,
.("cluster_sim_dist" = sum(sim_dist)),
by = "parent",
]
## second option: x child of cluster z -> gain = similarity to parent
# isolate competitors based on ids
child_parent_competitors <- unique_clustering_centers[
.(parent_children_ids),
on = "counting_id"
]
child_gains <- child_parent_competitors[
!.(parent_children_ids),
.("counting_id" = counting_id, "single_sim_dist" = sim_dist),
on = "parent"
]
# Compare gains
gains_comparison <- parent_gains[
child_gains,
"winner" := fifelse(
cluster_sim_dist >= single_sim_dist, "parent", "child"
),
on = .(parent == counting_id)
]
}
length(parent_children_ids)
parent_parent_winners
# isolate cases where there was pure parent vs parent competition
# this likely influences parent vs children competition and should be remerged to initial data
parent_parent_winners <- parent_parent_competitors[
parent != counting_id
]
parent_parent_winners
parent_parent_competitors
competing_parents
