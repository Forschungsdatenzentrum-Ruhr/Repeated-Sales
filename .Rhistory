#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
if("2" %in% inner_dummy$update_id){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent)) %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,match_type,repeated_id,update_id,obj_parent,etage_similar,zimmeranzahl_similar,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#printer(i)
print(i)
j = 1
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
View(inner_dummy)
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
#find last update
latest_update = which.max(inner_dummy$counting_id)
#filter out repeated offerings that are only updates
if("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
#filter out repeated offerings that are only updates
"2" == inner_dummy$update_id
"1" == inner_dummy$repeated_id
#filter out repeated offerings that are only updates
"2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id
#filter out repeated offerings that are only updates
sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id)
for(i in 5:5){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#printer(i)
print(i)
j = 1
while(j <= length(unique_wohnflaeche)){
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
#filter out repeated offerings that are only updates
if(sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id) >= 1){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent)) %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,match_type,repeated_id,update_id,obj_parent,etage_similar,zimmeranzahl_similar,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
View(final_list)
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
j = 1
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
final_list = c()
for(i in 1:10){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#printer(i)
print(i)
j = 1
while(j <= length(unique_wohnflaeche)){
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
#filter out repeated offerings that are only updates
if(sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id) >= 1){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent) & !update_id == "2" & !) %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,match_type,repeated_id,update_id,obj_parent,etage_similar,zimmeranzahl_similar,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
for(i in 1:10){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
#printer(i)
print(i)
j = 1
while(j <= length(unique_wohnflaeche)){
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
#filter out repeated offerings that are only updates
if(sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id) >= 1){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent) & !update_id == "2") %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,match_type,repeated_id,update_id,obj_parent,etage_similar,zimmeranzahl_similar,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
View(final_list)
final_list = c()
for(i in 1:10000){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
printer(i)
j = 1
while(j <= length(unique_wohnflaeche)){
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
#filter out repeated offerings that are only updates
if(sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id) >= 1){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent) & !update_id == "2") %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,repeated_id,update_id,obj_parent,time_diff,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
printer(i,by=10)
final_list = c()
for(i in 1:100){
#subset by unique coordination combination
outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
unique_wohnflaeche = unique(outer_dummy$wohnflaeche)
printer(i,by=10)
j = 1
while(j <= length(unique_wohnflaeche)){
#at least one exact match
if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
inner_dummy$match_type = "exact"
} else {
#range match
inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
inner_dummy$match_type = "range"
}
#extract inital offering
baseline = inner_dummy[1,]
#rangeChecker
inner_dummy = inner_dummy %>% mutate(
zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add"),
time_diff = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat))
)
#gen repeated id based on match type
inner_dummy = inner_dummy %>% mutate(repeated_id = case_when(
#is baseline
.$counting_id == baseline$counting_id ~ "0",
#both match, true repeated offering
.$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
#one matches, one similar, half-true repeated offering
.$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
.$etage_similar & .$zimmeranzahl == baseline$zimmeranzahl ~ "2",
#both are similar, similar repeated offering
.$etage_similar & .$zimmeranzahl_similar ~ "3",
#no matches
TRUE ~ "4"
)
) %>% mutate(update_id = case_when(
#same obj
.$repeated_id == 0 ~ "0",
#more than specified
.$time_diff >= as.numeric((time_offset_factor)) ~ "1",
#less than specified
TRUE ~ "2"
)
)  %>% mutate(obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA))
#filter out repeated offerings that are only updates
if(sum("2" == inner_dummy$update_id & "1" == inner_dummy$repeated_id) >= 1){
if("1" %in% inner_dummy$update_id){
earliest_sale = match("1", inner_dummy$update_id)
last_update_before_sale = inner_dummy$counting_id[which.max(inner_dummy$counting_id[1:earliest_sale - 1])]
remove_counting_ids = inner_dummy$counting_id[!(inner_dummy$counting_id == last_update_before_sale) & inner_dummy$update_id %in% c("0","2")]
outer_dummy = outer_dummy %>% filter(!counting_id %in% remove_counting_ids)
next
} else {
#this may be useless. if there are no sell-events there can be no repeated offerings
#find last update
latest_update = which.max(inner_dummy$counting_id)
preceding_counting_ids = inner_dummy$counting_id[1:latest_update - 1]
#remove all preceding updates, set last one as new baseline and redo loop step
outer_dummy = outer_dummy %>% filter(!counting_id %in% preceding_counting_ids)
next
}
}
final_inner = inner_dummy %>% filter(!is.na(obj_parent) & !update_id == "2") %>% select(wohnflaeche,etage,zimmeranzahl,counting_id,repeated_id,update_id,obj_parent,time_diff,latlon_utm)
final_list = rbind(final_list, final_inner)
rm(inner_dummy)
j = j + 1
}
rm(outer_dummy)
}
