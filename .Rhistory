cluster_names = NULL,
subset = NULL,
names_cluster_combinations = NULL,
distance_cluster_combinations = NULL,
index_cluster_combinations = NULL,
unique_cluster_combinations = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_names <- attr(cluster_options, "names")
self$cluster_options <- self$filter_unique_options(cluster_options)
self$distance <- distance
self$index <- cluster_options
self$sequence <- seq_along(self$cluster_names)
return(NULL)
},
make_cluster = function(unique_option) {
# assign temp data.table
parent <- attr(unique_option, "names")
parent_col <- which(parent == self$names_cluster_combinations)
temps <- data.table(
"counting_id" = as.numeric(self$names_cluster_combinations),
"parent" = as.numeric(parent),
"sim_dist" = as.numeric(unique_option |> unlist()),
"sim_index" = as.numeric(self$index_cluster_combinations[[parent_col]])
)
return(temps)
},
# NOTE: some legacy stuff here, clean up what isnt needed
filter_unique_options <- function(unique_options) {
if (!is.null(unique_options)) {
unique_options <- data.table::transpose(unique_options) |>
setnames(new = self$cluster_names)
unique_options <- unique(unique_options)
unique_options <- unique_options |>
is.na() |>
not() |>
apply(
1,
which,
simplify = F
)
return(unique_options)
}
},
# actual cluster sequence
determine_cluster_centers = function() {
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
# consider all unique combinations of clusters
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# consider all combinations within cluster
self$distance_cluster_combinations <- self$distance[self$subset, self$subset, with = F]
self$index_cluster_combinations <- self$index[self$subset, self$subset, with = F]
self$names_cluster_combinations <- attr(self$distance_cluster_combinations, "names")
# identify exact duplicates in combinations (happens when all inputs are exactly the same)
dups <- base::duplicated(self$distance_cluster_combinations, margin = 0)
# and drop those duplicates so we only deal with unique_combinations
unique_cluster_combinations <- self$distance_cluster_combinations[, !dups, with = F]
for (cluster_combination in seq_along(unique_cluster_combinations)) {
self$centers <- rbind(self$centers, self$make_cluster(unique_cluster_combinations[, cluster_combination, with = F]))
}
}
}
return(NULL)
}
)
)
all_named(private)
all_named(public)
all_named(active)
body(all_named)
debug(R6::R6Class)
# General notes:
# have to treat rows and columns to matrices differently since scaled distance "from to" are not equal to "to from"
# this is class since it has a lot of attributes and constant self-references
cluster <- R6::R6Class("cluster",
public = list(
# default values
cluster_options = NULL,
distance = NULL,
index = NULL,
sim_index = NULL,
sim_dist = NULL,
sequence = NULL,
cluster_names = NULL,
subset = NULL,
names_cluster_combinations = NULL,
distance_cluster_combinations = NULL,
index_cluster_combinations = NULL,
unique_cluster_combinations = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_names <- attr(cluster_options, "names")
self$cluster_options <- self$filter_unique_options(cluster_options)
self$distance <- distance
self$index <- cluster_options
self$sequence <- seq_along(self$cluster_names)
return(NULL)
},
make_cluster = function(unique_option) {
# assign temp data.table
parent <- attr(unique_option, "names")
parent_col <- which(parent == self$names_cluster_combinations)
temps <- data.table(
"counting_id" = as.numeric(self$names_cluster_combinations),
"parent" = as.numeric(parent),
"sim_dist" = as.numeric(unique_option |> unlist()),
"sim_index" = as.numeric(self$index_cluster_combinations[[parent_col]])
)
return(temps)
},
# NOTE: some legacy stuff here, clean up what isnt needed
filter_unique_options <- function(unique_options) {
if (!is.null(unique_options)) {
unique_options <- data.table::transpose(unique_options) |>
setnames(new = self$cluster_names)
unique_options <- unique(unique_options)
unique_options <- unique_options |>
is.na() |>
not() |>
apply(
1,
which,
simplify = F
)
return(unique_options)
}
},
# actual cluster sequence
determine_cluster_centers = function() {
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
# consider all unique combinations of clusters
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# consider all combinations within cluster
self$distance_cluster_combinations <- self$distance[self$subset, self$subset, with = F]
self$index_cluster_combinations <- self$index[self$subset, self$subset, with = F]
self$names_cluster_combinations <- attr(self$distance_cluster_combinations, "names")
# identify exact duplicates in combinations (happens when all inputs are exactly the same)
dups <- base::duplicated(self$distance_cluster_combinations, margin = 0)
# and drop those duplicates so we only deal with unique_combinations
unique_cluster_combinations <- self$distance_cluster_combinations[, !dups, with = F]
for (cluster_combination in seq_along(unique_cluster_combinations)) {
self$centers <- rbind(self$centers, self$make_cluster(unique_cluster_combinations[, cluster_combination, with = F]))
}
}
}
return(NULL)
}
)
)
names(x)
# General notes:
# have to treat rows and columns to matrices differently since scaled distance "from to" are not equal to "to from"
# this is class since it has a lot of attributes and constant self-references
cluster <- R6::R6Class("cluster",
public = list(
# default values
cluster_options = NULL,
distance = NULL,
index = NULL,
sim_index = NULL,
sim_dist = NULL,
sequence = NULL,
cluster_names = NULL,
subset = NULL,
names_cluster_combinations = NULL,
distance_cluster_combinations = NULL,
index_cluster_combinations = NULL,
unique_cluster_combinations = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_names <- attr(cluster_options, "names")
self$cluster_options <- self$filter_unique_options(cluster_options)
self$distance <- distance
self$index <- cluster_options
self$sequence <- seq_along(self$cluster_names)
return(NULL)
},
make_cluster = function(unique_option) {
# assign temp data.table
parent <- attr(unique_option, "names")
parent_col <- which(parent == self$names_cluster_combinations)
temps <- data.table(
"counting_id" = as.numeric(self$names_cluster_combinations),
"parent" = as.numeric(parent),
"sim_dist" = as.numeric(unique_option |> unlist()),
"sim_index" = as.numeric(self$index_cluster_combinations[[parent_col]])
)
return(temps)
},
# NOTE: some legacy stuff here, clean up what isnt needed
filter_unique_options = function(unique_options) {
if (!is.null(unique_options)) {
unique_options <- data.table::transpose(unique_options) |>
setnames(new = self$cluster_names)
unique_options <- unique(unique_options)
unique_options <- unique_options |>
is.na() |>
not() |>
apply(
1,
which,
simplify = F
)
return(unique_options)
}
},
# actual cluster sequence
determine_cluster_centers = function() {
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
# consider all unique combinations of clusters
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# consider all combinations within cluster
self$distance_cluster_combinations <- self$distance[self$subset, self$subset, with = F]
self$index_cluster_combinations <- self$index[self$subset, self$subset, with = F]
self$names_cluster_combinations <- attr(self$distance_cluster_combinations, "names")
# identify exact duplicates in combinations (happens when all inputs are exactly the same)
dups <- base::duplicated(self$distance_cluster_combinations, margin = 0)
# and drop those duplicates so we only deal with unique_combinations
unique_cluster_combinations <- self$distance_cluster_combinations[, !dups, with = F]
for (cluster_combination in seq_along(unique_cluster_combinations)) {
self$centers <- rbind(self$centers, self$make_cluster(unique_cluster_combinations[, cluster_combination, with = F]))
}
}
}
return(NULL)
}
)
)
undebug(R6::R6Class)
base::gc()
tar_make()
tar_make()
?str_detect
tar_load(WK_file_name)
RED_file_name = WK_file_name
#----------------------------------------------
# read stata file and remove labels
RED_full_data <- haven::read_dta(RED_file_name) |>
haven::zap_labels() |>
data.table::as.data.table()
# mutations
RED_full_data[
,
":="(
# combine coordinates
latlon_utm = paste0(lat_utm, lon_utm),
# transform years into months and add running years months
amonths = ajahr * 12 + amonat,
emonths = ejahr * 12 + emonat,
# combine price and rent into one variable
price_var = pmax(mietekalt, kaufpreis),
# create unique id for entire data
counting_id = 1:.N
)
]
str_detect(RED_file_name, "HK_")
# HK specific change
if (str_detect(RED_file_name, "HK_")) {
# reassign etage to anzahletage since etage is not used in HK
RED_full_data[, etage := anzahletagen]
}
# set key for faster merging
setkey(RED_full_data, counting_id)
#----------------------------------------------
# Unit test
tar_assert_true(
all(
c("latlon_utm", "amonths", "emonths", "price_var", "counting_id") %in% names(RED_full_data),
msg = "Not all essential variables are present in the data."
)
)
c("latlon_utm", "amonths", "emonths", "price_var", "counting_id") %in% names(RED_full_data)
#----------------------------------------------
# Unit test
tar_assert_true(
all(c("latlon_utm", "amonths", "emonths", "price_var", "counting_id") %in% names(RED_full_data)),
msg = "Not all essential variables are present in the data."
)
tar_make()
base::gc()
tar_make()
tar_make()
tar_make()
enquote()
enquote(test)
enquote("test")
tar_make_future(workers = 2)
tar_make_future(workers = 2)
tar_make_future(workers = 2)
tar_load(WK_classified)
tar_load(WK_prepared_repeated)
data_type = "WK"
tar_load_globals()
RED_classified = WK_classified
prepared_repeated = WK_prepared_repeated
make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss
#' @param RED_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
list_var
?lapply
fixed_effects <- list_var$fixed_effects
binary_names = list_var$binary_names
cont_names = list_var$cont_names
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
RED_classified
# reduce listings to only repeats and set missings to zero
pure_rs <- RED_classified[
hybrid_type == "repeat",
..var_to_keep
]
changed_boolean <- pure_rs[,
lapply(.SD, function(x) {
c(NA, diff(x))
}),
by = rs_id,
.SDcols = setdiff(var_to_keep, c("rs_id", "emonths", "depVar", "counting_id"))
][, rs_id := NULL] |> rowSums() != 0
RED_classified
str(RED_classified)
RED_classified <- prepare_hedonic(RED_classified, data_type)
prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tar_make()
tar_make_future(workers = 3)
tar_make()
tar_load_globals()
tar_load(WK_classified)
tar_load(WK_prepared_repeated)
tar_load_globals()
make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
head(ss)
options(warn = 0)
ss = make_hybrid(WK_classified,WK_prepared_repeated,"WK")
ss
?otions
?options
RED_classified = WK_classified
prepared_repeated = WK_prepared_repeated
data_type = "WK"
#' @param RED_classified data.table. Classified RED data
#' @param prepared_repeated data.table. Prepared repeated data
#' @param data_type character. Data type of the classified RED data
#'
#' @note Build by me based on Case and Quigley 1991
#'
#' @return data.table. Hybrid index for the given data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(prepared_repeated, "data.table")
input_check(data_type, "character")
#----------------------------------------------
# prep, get some settings
list_var <- make_var_list(data_type = data_type)
depVar <- list_var$depVar
fixed_effects <- list_var$fixed_effects
binary_names = list_var$binary_names
cont_names = list_var$cont_names
# declare variables to keep
var_to_keep <- c(binary_names, cont_names, "rs_id", "emonths", "depVar", "counting_id")
# get ids of all listings that are classified as repeat sales (pure or changed)
all_rs <- prepared_repeated[["rs_id"]] |> unique()
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
# split into repeat and hedonic
# something in here causes a data.table warning: Invalid .internal.selfref detected
RED_classified <- prepare_hedonic(RED_classified, data_type)[, ":="(
hybrid_type = fifelse(rs_id %in% all_rs, "repeat", "hedonic"),
depVar = exp(get(depVar))
)]
tst = prepare_hedonic(RED_classified, data_type)
tst
#' @param RED_classified data.table. RED classified data.
#' @param data_type character. Type of data to be used. One of:
#' *WK = Wohnungskauf/ Apartments for sale
#' *WM = Wohnungsmiete/ Apartments for rent
#' *HK = Hauskauf/ Houses for sale
#'
#' @return data.table. Prepared hedonic index.
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
input_check(data_type, "character")
tar_assert_true(data_type %in% c("WK", "WM", "HK"), msg = "data_type must be one of WK, WM, HK")
#---------------------------------------------
if (data_type == "WK") {
prepared_hedonic <- make_hedonic_WK(RED_classified)
} else if (data_type == "WM") {
prepared_hedonic <- make_hedonic_WM(RED_classified)
} else if (data_type == "HK") {
prepared_hedonic <- make_hedonic_HK(RED_classified)
}
prepared_hedonic
#' @title Make Hedonic Index for WK
#'
#' @description Make the hedonic index for the WK data type
#' @param RED_classified data.table. Classified RED data
#'
#' @return data.table. Hedonic index for WK data type
#' @author Thorben Wiebe
#----------------------------------------------
# Input validation
input_check(RED_classified, "data.table")
# setup of regression
list_var <- make_var_list(data_type = "WK")
depVar <- list_var$depVar
indepVar <- list_var$indepVar
fixed_effects <- list_var$fixed_effects
# depVar prep
RED_classified[kaufpreis < 0, kaufpreis := 0]
RED_classified[, "ln_flatprice_sqm" := log(kaufpreis / wohnflaeche)]
tar_load_globals()
make_hybrid(WK_classified,WK_prepared_repeated, "WK")
ss = make_hybrid(WK_classified,WK_prepared_repeated, "WK")
ss
tar_make_future(workers = 2)
