"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
for(cluster_option in self$cluster_options){
# subset to current cluster_option
self$subset = self$sequence[self$cluster_names %in% names(cluster_option)]
# extract minimum
self$min_ss = self$subset[which.min(self$means[self$subset])]
# assign both temp data.table
temp2 = data.table(
"sim_dist" = as.numeric(self$distance[self$min_ss,self$subset, with = F])
)
# bind temp data.table with itself for each iteration
#print(self$sim_dist)
#print(t(temp2))
self$sim_dist = rbind(self$sim_dist, temp2)
# assign both temp data.table
temp3 = data.table(
"sim_index" = as.numeric(self$index[self$min_ss,self$subset, with = F])
)
# bind temp data.table with itself for each iteration
#print(self$sim_dist)
#print(t(temp2))
self$sim_index = rbind(self$sim_index, temp3)
if(any(is.na(temp3$sim_index))){
tst<<- self
stop()
}
# assign temp data.table
temp = data.table(
"counting_id" = as.numeric(names(cluster_option)),
"parent" = as.numeric(self$cluster_names[self$min_ss])
)
# bind temp data.table with itself for each iteration
self$centers = rbind(self$centers, temp)
}
# overwrite total dist with current rel distance
self$centers$sim_dist = self$sim_dist
self$centers$sim_index = self$sim_index
}
}
)
)
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
cluster_options = similarity_index_list,
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
View(tst)
View(similarity_index_list)
tst[["subset"]]
# find duplicates
duplicates <- duplicated(geo_grouped_data[, ..categories])
# extract ids and combinations of non-duplicates
first_occurence_ids <- geo_grouped_data[!duplicates, counting_id]
# does order matter here? key = amonths?
unique_combinations <- geo_grouped_data[!duplicates, ..categories]
similarity_index_list <- similarity_dist_list <- list()
unique_combinations[, etage := etage + 1]
## similiarity calculations
for (i in 1:nrow(unique_combinations)) {
# percentage of rooms scaled values are allowed to be off
# e.g. what percentage of 8 rooms is 0.5 rooms
# this feels way to complicated
scaled_zimmeranzahl_r_o <- unique_combinations[
,
(as.numeric(unique_combinations[i, "zimmeranzahl"]) + zimmeranzahl_r_o) / as.numeric(unique_combinations[i, "zimmeranzahl"]) - 1
]
# scaling around 0 causes div by 0 and inf for everything else
# just increase etage by one? other solution?
data_to_similarity <- scale(unique_combinations, center = F, scale = unique_combinations[i]) |> as.data.table()
similarity_index_list[[i]] <- data_to_similarity[
,
.(fcase(
## exact repeat [small percentage deviation acceptable]
abs(1 - wohnflaeche) <= wohnflaeche_e_o &
# zimmeranzahl and etage are exact matches
zimmeranzahl == 1 &
etage == 1,
0,
## similar repeat [larger percentage deviation acceptable]
abs(1 - wohnflaeche) <= wohnflaeche_r_o &
# zimmeranzahl deviation acceptable / etage arbitrary
abs(1 - zimmeranzahl) <= scaled_zimmeranzahl_r_o,
1,
# no matches
default = NA
))
] |> as.matrix()
similarity_dist_list[[i]] <- as.matrix(dist(data_to_similarity, method = "euclidean"))[i, ]
}
## clustering
# transform to data.tables and set counting ids as column names
similarity_dist_list <- as.data.table(similarity_dist_list)
similarity_index_list <- as.data.table(similarity_index_list)
setnames(similarity_index_list, as.character(first_occurence_ids))
setnames(similarity_dist_list, as.character(first_occurence_ids))
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
# since apply performs action on rows while all other functions use columns
cluster_options = data.table::transpose(similarity_index_list),
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
styler:::style_active_file()
styler:::style_active_file()
# Cluster Class
cluster <- R6::R6Class("cluster",
public = list(
# default values
cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
sim_index = NULL,
sim_dist = NULL,
sequence = NULL,
cluster_names = NULL,
subset = NULL,
min_ss = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
subset = NULL,
min_ss = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_options <- if (!is.null(cluster_options)) {
unique(
apply(
!is.na(
data.table::transpose(cluster_options)
),
1,
which,
simplify = F
)
)
}
self$cluster_names <- attr(cluster_options, "names")
self$distance <- distance
self$index <- cluster_options
self$means <- means
self$sequence <- seq_along(means)
},
# actual cluster sequence
determine_cluster_centers = function() {
# consider all unique combinations of clusters
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# extract minimum
self$min_ss <- self$subset[which.min(self$means[self$subset])]
# assign both temp data.table
temp2 <- data.table(
"sim_dist" = as.numeric(self$distance[self$min_ss, self$subset, with = F])
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_dist <- rbind(self$sim_dist, temp2)
# assign both temp data.table
temp3 <- data.table(
"sim_index" = as.numeric(self$index[self$min_ss, self$subset, with = F])
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_index <- rbind(self$sim_index, temp3)
if (any(is.na(temp3$sim_index))) {
tst <<- self
stop()
}
# assign temp data.table
temp <- data.table(
"counting_id" = as.numeric(names(cluster_option)),
"parent" = as.numeric(self$cluster_names[self$min_ss])
)
# bind temp data.table with itself for each iteration
self$centers <- rbind(self$centers, temp)
}
# overwrite total dist with current rel distance
self$centers$sim_dist <- self$sim_dist
self$centers$sim_index <- self$sim_index
}
}
)
)
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
# since apply performs action on rows while all other functions use columns
cluster_options = similarity_index_list,
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
warnings()
tst$cluster_options
# find duplicates
duplicates <- duplicated(geo_grouped_data[, ..categories])
# extract ids and combinations of non-duplicates
first_occurence_ids <- geo_grouped_data[!duplicates, counting_id]
# does order matter here? key = amonths?
unique_combinations <- geo_grouped_data[!duplicates, ..categories]
similarity_index_list <- similarity_dist_list <- list()
unique_combinations[, etage := etage + 1]
## similiarity calculations
for (i in 1:nrow(unique_combinations)) {
# percentage of rooms scaled values are allowed to be off
# e.g. what percentage of 8 rooms is 0.5 rooms
# this feels way to complicated
scaled_zimmeranzahl_r_o <- unique_combinations[
,
(as.numeric(unique_combinations[i, "zimmeranzahl"]) + zimmeranzahl_r_o) / as.numeric(unique_combinations[i, "zimmeranzahl"]) - 1
]
# scaling around 0 causes div by 0 and inf for everything else
# just increase etage by one? other solution?
data_to_similarity <- scale(unique_combinations, center = F, scale = unique_combinations[i]) |> as.data.table()
similarity_index_list[[i]] <- data_to_similarity[
,
.(fcase(
## exact repeat [small percentage deviation acceptable]
abs(1 - wohnflaeche) <= wohnflaeche_e_o &
# zimmeranzahl and etage are exact matches
zimmeranzahl == 1 &
etage == 1,
0,
## similar repeat [larger percentage deviation acceptable]
abs(1 - wohnflaeche) <= wohnflaeche_r_o &
# zimmeranzahl deviation acceptable / etage arbitrary
abs(1 - zimmeranzahl) <= scaled_zimmeranzahl_r_o,
1,
# no matches
default = NA
))
] |> as.matrix()
similarity_dist_list[[i]] <- as.matrix(dist(data_to_similarity, method = "euclidean"))[i, ]
}
## clustering
# transform to data.tables and set counting ids as column names
similarity_dist_list <- as.data.table(similarity_dist_list)
similarity_index_list <- as.data.table(similarity_index_list)
setnames(similarity_index_list, as.character(first_occurence_ids))
setnames(similarity_dist_list, as.character(first_occurence_ids))
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
# since apply performs action on rows while all other functions use columns
cluster_options = similarity_index_list,
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
tst$cluster_options
?data.table::transpose
?transpose
# Cluster Class
cluster <- R6::R6Class("cluster",
public = list(
# default values
cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
sim_index = NULL,
sim_dist = NULL,
sequence = NULL,
cluster_names = NULL,
subset = NULL,
min_ss = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
subset = NULL,
min_ss = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_names <- attr(cluster_options, "names")
self$cluster_options <- if (!is.null(cluster_options)) {
unique(
apply(
!is.na(
data.table::transpose(cluster_options) |> setnames(new = self$cluster_names)
),
1,
which,
simplify = F
)
)
}
self$distance <- distance
self$index <- cluster_options
self$means <- means
self$sequence <- seq_along(means)
},
# actual cluster sequence
determine_cluster_centers = function() {
# consider all unique combinations of clusters
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# extract minimum
self$min_ss <- self$subset[which.min(self$means[self$subset])]
# assign both temp data.table
temp2 <- data.table(
"sim_dist" = as.numeric(self$distance[self$min_ss, self$subset, with = F])
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_dist <- rbind(self$sim_dist, temp2)
# assign both temp data.table
temp3 <- data.table(
"sim_index" = as.numeric(self$index[self$min_ss, self$subset, with = F])
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_index <- rbind(self$sim_index, temp3)
if (any(is.na(temp3$sim_index))) {
tst <<- self
stop()
}
# assign temp data.table
temp <- data.table(
"counting_id" = as.numeric(names(cluster_option)),
"parent" = as.numeric(self$cluster_names[self$min_ss])
)
# bind temp data.table with itself for each iteration
self$centers <- rbind(self$centers, temp)
}
# overwrite total dist with current rel distance
self$centers$sim_dist <- self$sim_dist
self$centers$sim_index <- self$sim_index
}
}
)
)
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
# since apply performs action on rows while all other functions use columns
cluster_options = similarity_index_list,
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
View(tst)
clustering$cluster_options
View(similarity_dist_list)
View(similarity_index_list)
View(tst)
clustering$min_ss
as.numeric(clustering$distance[clustering$min_ss, clustering$subset, with = F])
as.numeric(clustering$index[clustering$min_ss, clustering$subset, with = F])
clustering$index[clustering$subset,clustering$min_ss,  with = F]
clustering$index[clustering$subset,clustering$min_ss,  with = F] |> pull()
# Cluster Class
cluster <- R6::R6Class("cluster",
public = list(
# default values
cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
sim_index = NULL,
sim_dist = NULL,
sequence = NULL,
cluster_names = NULL,
subset = NULL,
min_ss = NULL,
centers = NULL,
# initial value setup
initialize = function(cluster_options = NULL,
distance = NULL,
index = NULL,
means = NULL,
cluster_names = NULL,
sim_dist = data.table(),
sim_index = data.table(),
sequence = NULL,
subset = NULL,
min_ss = NULL,
centers = data.table()) {
# calculation helpers
self$cluster_names <- attr(cluster_options, "names")
self$cluster_options <- if (!is.null(cluster_options)) {
unique(
apply(
!is.na(
data.table::transpose(cluster_options) |> setnames(new = self$cluster_names)
),
1,
which,
simplify = F
)
)
}
self$distance <- distance
self$index <- cluster_options
self$means <- means
self$sequence <- seq_along(means)
},
# actual cluster sequence
determine_cluster_centers = function() {
# consider all unique combinations of clusters
# catch single obs cases. keep for now with parent = child
if (length(self$cluster_options) == 1 & 1 %in% lengths(self$cluster_options)) {
self$centers <- data.table(
"sim_dist" = 0,
"sim_index" = 0,
"counting_id" = as.numeric(self$cluster_names),
"parent" = as.numeric(self$cluster_names)
)
} else {
for (cluster_option in self$cluster_options) {
# subset to current cluster_option
self$subset <- self$sequence[self$cluster_names %in% names(cluster_option)]
# extract minimum
self$min_ss <- self$subset[which.min(self$means[self$subset])]
# assign both temp data.table
temp2 <- data.table(
"sim_dist" = as.numeric(self$distance[self$subset,self$min_ss,  with = F] |> pull())
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_dist <- rbind(self$sim_dist, temp2)
# assign both temp data.table
temp3 <- data.table(
"sim_index" = as.numeric(self$index[self$subset,self$min_ss,  with = F] |> pull())
)
# bind temp data.table with itself for each iteration
# print(self$sim_dist)
# print(t(temp2))
self$sim_index <- rbind(self$sim_index, temp3)
if (any(is.na(temp3$sim_index))) {
tst <<- self
stop()
}
# assign temp data.table
temp <- data.table(
"counting_id" = as.numeric(names(cluster_option)),
"parent" = as.numeric(self$cluster_names[self$min_ss])
)
# bind temp data.table with itself for each iteration
self$centers <- rbind(self$centers, temp)
}
# overwrite total dist with current rel distance
self$centers$sim_dist <- self$sim_dist
self$centers$sim_index <- self$sim_index
}
}
)
)
# setup and run the actual clustering
clustering <- cluster$new(
#just transpose this??
# since apply performs action on rows while all other functions use columns
cluster_options = similarity_index_list,
distance = similarity_dist_list*similarity_index_list,
means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)
clustering$determine_cluster_centers()
clustering$index[clustering$subset,clustering$min_ss,  with = F] |> pull()
View(similarity_index_list)
tst[["subset"]]
tst[["means"]]
tst$means[tst$subset]
clustering$subset[which.min(clustering$means[clustering$subset])]
tst$subset[which.min(tst$means[tst$subset])]
