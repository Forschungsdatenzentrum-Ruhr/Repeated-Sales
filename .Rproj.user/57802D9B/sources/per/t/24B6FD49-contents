removal = function(data_to_class, t_offset){
  
  repeated_offerings <- c()
  
  while (nrow(data_to_class) > 0) {
    
    candidates = data_to_class %>%
      mutate(
        # to last date in data
        td_to_end = (as.numeric(data_end_date) - as.numeric(emonths)),
        
        # to leading offering
        td_to_lead = (lead(as.numeric(amonths)) - as.numeric(emonths)),
        
        # replace last td_to_lead with td_to_end
        td_to_lead = replace_na(td_to_lead, td_to_end[is.na(td_to_lead)])
      )
    
    inital_id = candidates$counting_id[1]
    
    candidates %<>% filter(td_to_lead >= t_offset)
    
    ids = candidates %>% summarise(between_ext(.))
    
    candidates <- cbind(candidates,ids) %>%
      filter(repeated_id != -1)

      #remove true repeates from options since there can only be one
      ids_to_remove <- c(candidates$counting_id[candidates$repeated_id == 1],inital_id)
      
      data_to_class %<>% filter(!counting_id %in% ids_to_remove)
      
      #next step!
      #this is likely not correct yet, need to figure out what to remove what when
      if(!is.null(repeated_offerings) & length(ids_to_remove)> 2) {
        repeated_offerings %<>% filter(!counting_id %in% ids_to_remove)
      }
      
      repeated_offerings <- candidates %>%
        mutate(
          obj_parent = counting_id[1]
        ) %>%
        bind_rows(repeated_offerings)
    }
  return(repeated_offerings)
}


between_ext <- function(data, offsets = range_offsets) {

  # drop time for now
  col_names <- offsets$rowname[!offsets$rowname == "time"]

  data %<>% select(col_names)

  inital <- tbl_transpose(data[1, ],rownames = NA) %>%
    set_colnames("baseline") %>%
    rownames_to_column() %>%
    merge(offsets, by = "rowname", all.x = T) %>%
    summarise(
      rowname = rowname,
      similar_left = case_when(
        offset_type == "add" ~ baseline - similar_offset,
        offset_type == "multi" ~ baseline * (1 - similar_offset)
      ),
      similar_right = case_when(
        offset_type == "add" ~ baseline + similar_offset,
        offset_type == "multi" ~ baseline * (1 + similar_offset)
      ),
      exact_left = case_when(
        offset_type == "add" ~ baseline - exact_offset,
        offset_type == "multi" ~ baseline * (1 - exact_offset)
      ),
      exact_right = case_when(
        offset_type == "add" ~ baseline + exact_offset,
        offset_type == "multi" ~ baseline * (1 + exact_offset)
      )
    )

  between_id <- merge(inital, t(data), by.x = "rowname", by.y = 0) 
  
  #this should be moved into a function
  #might be time to split all these functions into their own files aswell
  cutoff = 1:match("similar_right",colnames(between_id))
  
  jaccard = between_id %>% tbl_transpose() %>% slice(-cutoff) %>% 
    summarise(
      across(
        everything(),
        ~type.convert(.x,as.is = T)))

  
  centers = jaccard %>% slice(1:2) %>% 
    summarise(across(everything(), ~mean(.x)))

  
  test = jaccard %>% slice(-1:-2) %>% scale(.,center = F, scale = centers) %>%
    jaccard_index(.)

  
  jaccard_index = function(data_to_jaccard){
    
    # entries with less than zero a this point are removed later
    data_to_jaccard[data_to_jaccard < 0] = NA
    
    # extract first column of jaccard distance matrix gives jaccard distance to potential parent
    jaccard = 1 - as.matrix(vegdist(data_to_jaccard, method = "jaccard"))[1,]
    
    return(jaccard)
  }
  
  
  
  repeated_id = between_id %>%
    summarise(
      across(
        starts_with("V"),
        ~ case_when(
          . >= exact_left & exact_right >= . ~ 1,
          . >= similar_left & similar_right >= . ~ 0,
          TRUE ~ -1
        )
      )
    )  %>%
    summarise(
      across(
        starts_with("V"),
        ~ case_when(
          -1 %in% . ~ -1,
          0 %in% . ~ 0,
          TRUE ~ 1
        )
      )
    ) %>%
    tbl_transpose()
  
  out = cbind(repeated_id, jaccard)
  names(out) = c("repeated_id","jaccard")
  
  return(out)
}

tbl_transpose = function(data_to_transpose,...){
  return(as_tibble(t(data_to_transpose),...))
}


classify_data <- function(latlon_utm) {
  
  ######################
  #Settings
  ######################
  range_offsets <<- tibble::tribble(
    ~rowname, ~similar_offset, ~exact_offset, ~offset_type,
    "wohnflaeche", 0.1, 0.05, "multi",
    "etage", 99, 0, "add",
    "zimmeranzahl", 0.5, 0, "add",
    "time", 0, 6, NA
  )
  # extract time offset for readability
  time_offset <- range_offsets$exact_offset[range_offsets$rowname == "time"]
  
  #group_mapping
  repeated_offerings = latlon_utm %>% group_by(latlon_utm, balkon) %>% arrange(amonths) %>% group_modify(
    ~removal(.x, t_offset = time_offset)
  )

  # throw out similar dups based on jaccard index?
  #count occurences of parent objects
  # final_outer = distinct(data)
  # test = data[duplicated(data),]
  # 
  # count_parents = final_outer %>% count(obj_parent)
  # keep_parents = count_parents[1][count_parents[2] > 1]
  # 
  # #drop if object is only its own parent
  # final_list = final_outer %>% filter(obj_parent %in% keep_parents) %>% arrange(obj_parent,counting_id)
  
  return(repeated_offerings)
  
}
