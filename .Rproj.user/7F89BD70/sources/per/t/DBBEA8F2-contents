######################
#Package Install Function
######################
packages_install = function(library_string){
  if (!require("pacman")) install.packages("pacman")
  pacman::p_load(library_string, character.only = TRUE)    
  print("Packages fully installed and loaded")
}

######################
#Packages
######################
library_string = c("here", # creating dynamic paths based on script location
                   "haven", # reading/writing of dta files
                   "tidyverse" # data manipulation/wrangeling
)
packages_install(library_string)
######################
#Paths
######################
path = paste0(here(),"/")
readpath = "M:/_FDZ/RWI-GEO/RWI-GEO-RED/daten/On-site/v6/"
writepath = paste0(path,"Data/Output/")

######################
#Functions
######################
rangeChecker = function(test_value,baseline_value,offset_value,offset_type="multi"){
  
  test_value = as.numeric(test_value)
  baseline_value = as.numeric(baseline_value)
  offset_value = as.numeric(offset_value)
  
  range = case_when(
    offset_type == "add" ~ c(baseline_value - offset_value, baseline_value + offset_value),
    offset_type == "multi" ~ c(baseline_value*(1 - offset_value), baseline_value*(1 + offset_value)),
    TRUE ~ c(0,0)
  )
    check = between(test_value,range[1],range[2])
    return(check)
}

printer = function(value,by=50){
  if(value %% by == 0){
    print(value)
  }
}

######################
#Prep
######################
wk_data = read_dta(paste0(readpath,"WK_allVersionsLabels.dta"))

#shrink data to necessary
berlin_only =
  wk_data %>%
  filter(
    # berlin
    blid == 11,
    # remove missings
    as.character(lat_utm) != "-9",
    as.character(lon_utm) != "-9",
    na.rm = TRUE
    ) %>%
  select(
    obid,
    uniqueID_gen,
    mietekalt,
    mietewarm,
    kaufpreis,
    wohnflaeche,
    etage,
    zimmeranzahl,
    dupID_gen,
    ajahr,
    amonat,
    ejahr,
    emonat,
    lat_utm,
    lon_utm
  ) %>%
  #new var
  mutate(
    latlon_utm = paste0(lat_utm,lon_utm),
    #monat + 12 to avoid sorting issues in same year
    ajahrmonat = paste0(ajahr,amonat+12),
    ejahrmonat = paste0(ejahr,emonat+12)
  )
rm(wk_data)

######################
#Declarations
######################
#vars are allowed to deviate up to this factor in both directions
wohnflaeche_offset_factor = 0.1
etage_offset_factor = 99
zimmeranzahl_offset_factor = 0.5
time_offset_factor = 6

data_end_date = max(berlin_only$ejahrmonat)

final_list = c()

unique_latlon = unique(berlin_only$latlon_utm)
berlin_only$counting_id = 1:dim(berlin_only)[1]

######################
#Classifcations
######################

#length(unique_latlon)
for(i in 1:100){
  #subset by unique coordination combination
  outer_dummy = filter(berlin_only, latlon_utm == unique_latlon[i])
  outer_dummy = outer_dummy[order(outer_dummy$ajahrmonat),]
  unique_wohnflaeche = unique(outer_dummy$wohnflaeche)

  printer(i,by = 10)
  #print(i)
  for(j in 1:length(unique_wohnflaeche)){
    
    ##subset by exact/range match in wohnflaeche
    #at least one exact match
    if(sum(outer_dummy$wohnflaeche == unique_wohnflaeche[j]) >= 2){
      inner_dummy = filter(outer_dummy, wohnflaeche == unique_wohnflaeche[j])
      inner_dummy$match_type = "exact"
    } else {
      #range match
      inner_dummy = filter(outer_dummy, rangeChecker(wohnflaeche, unique_wohnflaeche[j], wohnflaeche_offset_factor, "multi"))
      inner_dummy$match_type = "range"
        
      #cutoff all preceding offerings
      #these cannot be repeated offerings since they were offered before candidate
      inner_dummy = inner_dummy[match(unique_wohnflaeche[j],inner_dummy$wohnflaeche):length(inner_dummy$wohnflaeche),]
    } 


#Updates
######################   
    
    ##gen time differences
    inner_dummy = inner_dummy %>% mutate(
      
      #to last date in data
      td_to_end = (as.numeric(data_end_date) - as.numeric(inner_dummy$ajahrmonat)),
      #of leading offering
      td_of_lead = (lead(as.numeric(inner_dummy$ejahrmonat)) - as.numeric(inner_dummy$ajahrmonat))
    )
    
    #replace last td_of_lead with td_to_end
    inner_dummy$td_of_lead[is.na(inner_dummy$td_of_lead)] = inner_dummy$td_to_end[is.na(inner_dummy$td_of_lead)]

    #drops updates
    inner_dummy = inner_dummy %>% filter(
      .$td_of_lead >= as.numeric((time_offset_factor))
      
    ##intermediary cleanup    
    ) %>% select(
      #drop unused columns
      -td_to_end
    )
    
#Repeated
###################### 
    
    #extract inital offering
    baseline = inner_dummy[1,]
    
    ##gen similarity dummys
    inner_dummy = inner_dummy %>% mutate(

      #rooms
      zimmeranzahl_similar = rangeChecker(inner_dummy$zimmeranzahl, baseline$zimmeranzahl, zimmeranzahl_offset_factor, "add"),
      #floors
      etage_similar = rangeChecker(inner_dummy$etage, baseline$etage, etage_offset_factor, "add")
    
      ) %>% mutate(
        ##gen repeated indicator
        repeated_id = case_when(
    
          #is same offering
          .$counting_id == baseline$counting_id ~ "0",
          
          #both match; true repeated offering
          .$etage == baseline$etage & .$zimmeranzahl == baseline$zimmeranzahl ~ "1",
          
          #floor matches, rooms similar; half-true repeated offering
          #change to 1 later
          .$etage == baseline$etage & .$zimmeranzahl_similar ~ "2",
          
          #both are similar, resembling repeated offering
          .$etage_similar & .$zimmeranzahl_similar ~ "3",
          
          #no matches
          TRUE ~ "4"
      ),
        ##gen proposed object parent
        obj_parent = ifelse(repeated_id != 4,baseline$counting_id,NA)
    )
    ##final cleanup        
    final_inner = inner_dummy %>% 
      #drop offerings without parent
      filter(!is.na(obj_parent)) %>%
      #drop all colums but those of interest
      select(counting_id,obj_parent,repeated_id,match_type,wohnflaeche,etage,zimmeranzahl,latlon_utm)
    
    #append to master and remove wohnflaeche subset array
    final_list = rbind(final_list, final_inner)
    rm(inner_dummy)
  }
  #remove unique coordination combination subset array
  rm(outer_dummy)
}

#stopped here
sum(final_list$counting_id[2] == final_list$obj_parent)

######################
#Variables of interest
######################
#to inital offering
#td_to_start = (as.numeric(inner_dummy$ajahrmonat) - as.numeric(baseline$ejahrmonat)),


######################
#Cleanup 
######################
#rm(list = setdiff(setdiff(ls(),c("readpath","writepath","path")), lsf.str()))

