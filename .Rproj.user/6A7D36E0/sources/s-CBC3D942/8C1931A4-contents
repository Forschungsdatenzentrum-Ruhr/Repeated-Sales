removal <- function(geo_grouped_data = NA) {
#' @title WIP
#'
#' @description WIP
#' @param WIP
#' @param WIP
#' @note
#'
#' @return WIP
#' @author Thorben Wiebe
#----------------------------------------------

# Cluster Class
cluster = R6::R6Class("cluster",
                      public = list(
                        
                        # default values
                        cluster_options = NULL,
                        distance = NULL,
                        means = NULL,
                        sim_dist = NULL,
                        sequence = NULL,
                        cluster_names = NULL,
                        subset = NULL,
                        min_ss = NULL,
                        centers = NULL,
                        
                        # initial value setup
                        initialize = function(initial_cluster_options = NULL,
                                              distance = NULL,
                                              means = NULL,
                                              cluster_names = NULL,
                                              sim_dist = data.table(),
                                              sequence = NULL,
                                              subset = NULL,
                                              min_ss = NULL,
                                              centers = data.table()) {
                          
                          # calculation helpers
                          self$cluster_options <-  unique(apply(!is.na(initial_cluster_options),1,which))
                          self$distance = distance
                          self$means = means
                          self$sequence = seq_along(self$means)
                          
                        },
                        # actual cluster sequence
                        determine_cluster_centers = function(){
                          
                          # consider all unique combinations of clusters
                          # catch single obs cases. keep for now with parent = child
                          if(length(self$cluster_options) == 1){
                            self$cluster_names = attr(cluster_options,"names")
                            
                            self$centers = data.table(
                              "sim_dist" = 0,
                              "counting_id" = as.numeric(self$cluster_names),
                              "parent" = as.numeric(self$cluster_names)
                              )
                          } else {
                            
                            self$cluster_names = attr(self$cluster_options |> unlist(),"names")
                            
                            for(cluster_option in self$cluster_options){
                              
                              # subset to current cluster_option
                              self$subset = self$sequence[self$cluster_names %in% names(cluster_option)]
                              
                              # extract minimum 
                              self$min_ss = self$subset[which.min(self$means[self$subset])]
                              
                              # assign both temp data.table
                              temp2 = data.table(
                                "sim_dist" = self$distance[self$min_ss,self$subset, with = F]
                              )
                              # bind temp data.table with itself for each iteration
                              self$sim_dist = rbind(self$sim_dist, t(temp2))
                              
                              # assign temp data.table
                              temp = data.table(
                                "counting_id" = as.numeric(names(cluster_option)),
                                "parent" = self$cluster_names[self$min_ss]
                              )
                              # bind temp data.table with itself for each iteration
                              self$centers = rbind(self$centers, temp)
                              
                            }
                            # overwrite total dist with current rel distance
                            self$centers$sim_dist = self$sim_dist
                          }
                            
                          }
                          
                      )
                      
                      
)
#backup = geo_grouped_data
#geo_grouped_data = geo_grouped_data[latlon_utm == "5875229.2228758489852.393390022"]


duplicates <- duplicated(geo_grouped_data[, ..categories])

first_occurence_ids <- geo_grouped_data[!duplicates, counting_id]
unique_combinations <- geo_grouped_data[!duplicates, ..categories]

setkey(unique_combinations, wohnflaeche, etage, zimmeranzahl)

similarity_index_list <- similarity_dist_list <- list()

for (i in 1:nrow(unique_combinations)) {

  # percentage of rooms scaled values are allowed to be off
  # e.g. what percentage of 8 rooms is 0.5 rooms
  # this feels way to complicated
  scaled_zimmeranzahl_r_o <- unique_combinations[
    ,
    (as.numeric(unique_combinations[i, "zimmeranzahl"]) + zimmeranzahl_r_o) / as.numeric(unique_combinations[i, "zimmeranzahl"]) - 1
  ]

  data_to_similarity <- scale(unique_combinations, center = F, scale = unique_combinations[i]) |> as.data.table()

  similarity_index_list[[i]] <- data_to_similarity[, .(fcase(
    ## exact repeat
    # percentage deviation acceptable
    abs(1 - wohnflaeche) <= wohnflaeche_e_o &
      # zimmeranzahl and etage are exact matches
      zimmeranzahl == 1 &
      etage == 1,
    0,

    ## similar repeat
    # percentage deviation acceptable
    abs(1 - wohnflaeche) <= wohnflaeche_r_o &
      # zimmeranzahl deviation acceptable
      abs(1 - zimmeranzahl) <= scaled_zimmeranzahl_r_o,
    1,

    # no matches
    default = NA
  ))] |> as.matrix()

  similarity_dist_list[[i]] <- as.matrix(dist(data_to_similarity, method = "euclidean"))[i, ]
}
# transform to data.tables and set counting ids as column names
similarity_dist_list <- as.data.table(similarity_dist_list)
similarity_index_list <- as.data.table(similarity_index_list)

setnames(similarity_index_list, as.character(first_occurence_ids))
setnames(similarity_dist_list, as.character(first_occurence_ids))

# setup and run the actual clustering
clustering <- cluster$new(
  initial_cluster_options = similarity_index_list,
  distance = similarity_dist_list,
  means = rowMeans(similarity_index_list * similarity_dist_list, na.rm = T)
)

clustering$determine_cluster_centers()

print(clustering$centers)
# merge cluster results to inital data and return
out = geo_grouped_data[
  clustering$centers,
  on = "counting_id",
  allow.cartesian = T
]

 
 return(out)
 
}
